#
# resolve.nix — turn a gemset config into an attrset of built derivations
#
# Supports two input formats:
#
# 1. Legacy list (backward compat):
#   [
#     { name = "rack"; version = "3.2.4"; }
#     { name = "rails"; git = { rev = "60d92e4e7dfe"; }; }
#   ]
#
# 2. Module-style attrset:
#   {
#     gem.rack = { enable = true; version = "3.2.4"; };
#     gem.rails = { enable = true; git.rev = "60d92e4e7dfe"; };
#   }
#
# App presets (generated by bin/import):
#   { gem.app.fizzy.enable = true; }
#   This pulls in all gems for the fizzy app at their locked versions.
#
# Usage:
#   resolve = import ./nix/modules/resolve.nix;
#   gems = resolve {
#     inherit pkgs ruby;
#     gemset = import ./nix/app/fizzy.nix;
#   };
#   builtins.attrValues gems  -> list of derivations
#
{
  pkgs,
  ruby,
  gemset,
}:

let
  inherit (pkgs) lib stdenv;
  gem =
    name: args:
    import (../gem + "/${name}") (
      {
        inherit
          lib
          stdenv
          ruby
          pkgs
          ;
      }
      // args
    );

  # All known app presets (generated by bin/import)
  appPresets = import ./apps.nix;

  # Normalize: convert module-style attrset to a list of entries
  normalized =
    if builtins.isList gemset then
      # Legacy list format — pass through
      gemset
    else
      let
        cfg = gemset;

        # Expand app presets: gem.app.<name>.enable = true pulls in all gems for that app
        appGems =
          if cfg ? gem && cfg.gem ? app then
            let
              enabledApps = lib.filterAttrs (_: v: v.enable or false) cfg.gem.app;
              appEntries = lib.concatMap (
                name:
                if appPresets ? ${name} then
                  appPresets.${name}
                else
                  throw "gem.app.${name}: unknown app. Available: ${builtins.concatStringsSep ", " (builtins.attrNames appPresets)}"
              ) (builtins.attrNames enabledApps);
            in
            appEntries
          else
            [ ];

        # Direct gem configs: gem.<name> = { enable = true; version = "..."; }
        directGems =
          if cfg ? gem then
            let
              # Filter out the "app" key and any disabled gems
              gemCfg = lib.filterAttrs (n: v: n != "app" && builtins.isAttrs v && (v.enable or false)) cfg.gem;
            in
            lib.mapAttrsToList (
              name: v:
              if v ? git then
                {
                  inherit name;
                  git = v.git;
                }
              else
                {
                  inherit name;
                  version = v.version;
                }
            ) gemCfg
          else
            [ ];
      in
      # Direct gems override app gems (by name)
      let
        directByName = builtins.listToAttrs (
          map (e: {
            name = e.name;
            value = e;
          }) directGems
        );
        appFiltered = builtins.filter (e: !(directByName ? ${e.name})) appGems;
      in
      appFiltered ++ directGems;

  resolve =
    entry:
    if entry ? git then
      {
        name = "${entry.name}-${entry.git.rev}";
        value = gem entry.name { inherit (entry) git; };
      }
    else
      {
        inherit (entry) name;
        value = gem entry.name { inherit (entry) version; };
      };
in
let
  gems = builtins.listToAttrs (map resolve normalized);
  bundlePath = pkgs.buildEnv {
    name = "gemset2nix-bundle";
    paths = builtins.attrValues gems;
  };
in
gems // { inherit bundlePath; }
