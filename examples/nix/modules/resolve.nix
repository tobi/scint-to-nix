#
# resolve.nix — turn a dependency config into built derivations + devShell
#
# Config format:
#   {
#     onix.apps.rails.enable = true;                              # app preset
#     onix.ruby.rack = { enable = true; version = "3.2.4"; };     # pin a gem
#   }
#
# Usage:
#   resolve = import ./nix/modules/resolve.nix;
#   env = resolve {
#     inherit pkgs ruby;
#     config = { onix.apps.fizzy.enable = true; };
#   };
#   env.devShell { buildInputs = with pkgs; [ sqlite ]; }
#   # env.onix.ruby.bundlePath — merged BUNDLE_PATH
#
{
  pkgs,
  ruby,
  config,
  # Legacy compat: accept gemset as alias for config
  gemset ? null,
}:

let
  inherit (pkgs) lib stdenv;
  cfg = if gemset != null then gemset else config;

  gem =
    name: args:
    import (../gem + "/${name}") (
      {
        inherit
          lib
          stdenv
          ruby
          pkgs
          ;
      }
      // args
    );

  # All known app presets (generated by bin/import)
  appPresets = import ./apps.nix;

  # Normalize config to a flat list of { name; version; } or { name; git; }
  normalized =
    if builtins.isList cfg then
      # Legacy list format — pass through
      cfg
    else
      let
        onixCfg = cfg.onix or {};

        # App presets: onix.apps.<name>.enable = true
        appGems =
          let
            appsCfg = onixCfg.apps or
              # Legacy: onix.ruby.app, deps.gem.app, gem.app
              (if onixCfg ? ruby && onixCfg.ruby ? app then onixCfg.ruby.app
               else if cfg ? deps && cfg.deps ? gem && cfg.deps.gem ? app then cfg.deps.gem.app
               else if cfg ? gem && cfg.gem ? app then cfg.gem.app
               else {});
            enabledApps = lib.filterAttrs (_: v: v.enable or false) appsCfg;
          in
          lib.concatMap (
            name:
            if appPresets ? ${name} then
              appPresets.${name}
            else
              throw "onix.apps.${name}: unknown app. Available: ${builtins.concatStringsSep ", " (builtins.attrNames appPresets)}"
          ) (builtins.attrNames enabledApps);

        # Per-gem config: onix.ruby.<name> = { enable = true; version = "..."; }
        rubyCfg =
          let
            rc = onixCfg.ruby or
              # Legacy: deps.gem, gem
              (if cfg ? deps && cfg.deps ? gem then cfg.deps.gem
               else if cfg ? gem then cfg.gem
               else {});
          in
          # Strip "app" key (handled above)
          builtins.removeAttrs rc ["app"];

        directGems =
          let
            filtered = lib.filterAttrs (_: v: builtins.isAttrs v && (v.enable or false)) rubyCfg;
          in
          lib.mapAttrsToList (
            name: v:
            if v ? git then
              { inherit name; git = v.git; }
            else
              { inherit name; version = v.version; }
          ) filtered;
      in
      # Direct gems override app gems (by name)
      let
        directByName = builtins.listToAttrs (
          map (e: { name = e.name; value = e; }) directGems
        );
        appFiltered = builtins.filter (e: !(directByName ? ${e.name})) appGems;
      in
      appFiltered ++ directGems;

  resolveEntry =
    entry:
    if entry ? git then
      { name = "${entry.name}-${entry.git.rev}"; value = gem entry.name { inherit (entry) git; }; }
    else
      { inherit (entry) name; value = gem entry.name { inherit (entry) version; }; };

  gems = builtins.listToAttrs (map resolveEntry normalized);

  bundlePath = pkgs.buildEnv {
    name = "onix-bundle";
    paths = builtins.attrValues gems;
  };
in
gems // {
  onix.ruby.bundlePath = bundlePath;

  # Legacy alias
  inherit bundlePath;

  devShell = {
    name ? "onix-devshell",
    buildInputs ? [],
    shellHook ? "",
    ...
  }@args:
  pkgs.mkShell (builtins.removeAttrs args ["buildInputs" "shellHook" "name"] // {
    inherit name;
    buildInputs = [ ruby ] ++ buildInputs;
    shellHook = ''
      export BUNDLE_PATH="${bundlePath}"
      export BUNDLE_GEMFILE="''${BUNDLE_GEMFILE:-$PWD/Gemfile}"
    '' + shellHook;
  });
}
