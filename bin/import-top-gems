#!/usr/bin/env ruby
# frozen_string_literal: true

# import-top-gems — import the most-downloaded gems from a gem index
#
# Queries the index for the top N gems by download count, picks the
# latest M stable versions of each, writes a .gemset, then runs
# fetch + generate to materialise nix derivations.
#
# Supported indices:
#   rubygems   — rubygems.org (default)
#
# Usage:
#   bin/import-top-gems                              # top 1000, 3 versions, rubygems
#   bin/import-top-gems --top 500 --max-versions 1
#   bin/import-top-gems --index rubygems --top 2000
#   bin/import-top-gems --dry-run                    # just write the .gemset

require "fileutils"
require "json"
require "net/http"
require "uri"

ROOT       = File.expand_path(File.join(__dir__, ".."))
IMPORTS    = File.join(ROOT, "imports")
CACHE      = File.join(ROOT, "cache")

# ── Defaults ──────────────────────────────────────────────────────

index        = "rubygems"
top_n        = 1000
max_versions = 3
dry_run      = false
gemset_name  = nil   # auto from index

# ── CLI ───────────────────────────────────────────────────────────

i = 0
while i < ARGV.length
  case ARGV[i]
  when "--index", "-i"      then index        = ARGV[i += 1]
  when "--top", "-t"        then top_n        = ARGV[i += 1].to_i
  when "--max-versions", "-v" then max_versions = ARGV[i += 1].to_i
  when "--dry-run", "-d"    then dry_run       = true
  when "--name", "-n"       then gemset_name   = ARGV[i += 1]
  when "--help", "-h"
    $stderr.puts <<~USAGE
      Usage: import-top-gems [OPTIONS]

      Options:
        --index, -i NAME          Gem index to query (default: rubygems)
        --top, -t N               Number of top gems by downloads (default: 1000)
        --max-versions, -v N      Max stable versions per gem (default: 3)
        --name, -n NAME           Output gemset name (default: <index>-top)
        --dry-run, -d             Write .gemset only, skip fetch+generate

      Supported indices:
        rubygems                  rubygems.org
    USAGE
    exit 0
  else
    abort "Unknown option: #{ARGV[i]}"
  end
  i += 1
end

gemset_name ||= "#{index}-top"

# ── Index adapters ────────────────────────────────────────────────

module Index
  # Returns { names: [String], versions: { name => [ver, ...] } }
  # names is sorted by download count (most popular first), length = top_n
  # versions[name] is sorted by Gem::Version ascending (oldest first)

  module RubyGems
    SEARCH_URL  = "https://rubygems.org/api/v1/search.json"
    VERSIONS_URL = "https://rubygems.org/versions"
    PER_PAGE    = 30

    def self.fetch_top(top_n, max_versions)
      names = fetch_names(top_n)
      versions = fetch_versions(names, max_versions)
      { names: names, versions: versions }
    end

    def self.fetch_names(top_n)
      pages_needed = (top_n.to_f / PER_PAGE).ceil
      names = []

      pages_needed.times do |page_idx|
        page = page_idx + 1
        data = api_get("#{SEARCH_URL}?query=*&page=#{page}")
        break if data.empty?

        data.each { |g| names << g["name"] }
        $stderr.print "\r  #{names.size}/#{top_n} gem names"
        sleep 0.5  # be polite
        break if names.size >= top_n
      end

      $stderr.puts
      names.first(top_n)
    end

    def self.fetch_versions(names, max_versions)
      $stderr.puts "Downloading version index..."
      versions_file = File.join(CACHE, "rubygems-versions.txt")

      # Cache for 1 hour
      if !File.exist?(versions_file) || (Time.now - File.mtime(versions_file)) > 3600
        body = http_get(VERSIONS_URL)
        FileUtils.mkdir_p(CACHE)
        File.write(versions_file, body)
        $stderr.puts "  #{(body.bytesize / 1_000_000.0).round(1)} MB cached"
      else
        body = File.read(versions_file)
        $stderr.puts "  using cached index (#{(body.bytesize / 1_000_000.0).round(1)} MB)"
      end

      # Parse: "name ver1,ver2,... checksum"
      # A gem can appear on multiple lines (incremental updates) — merge them.
      lookup = {}
      body.each_line do |line|
        line = line.strip
        next if line.empty? || line.start_with?("---", "created_at")
        parts = line.split(" ", 3)
        next unless parts.size >= 2
        if lookup[parts[0]]
          lookup[parts[0]] << "," << parts[1]
        else
          lookup[parts[0]] = parts[1]
        end
      end

      result = {}
      names.each do |name|
        raw = lookup[name]
        unless raw
          $stderr.puts "  WARN: #{name} not in version index, skipping"
          next
        end

        all = raw.split(",")

        # Filter: ruby platform only, stable releases only
        stable = all.reject do |v|
          v =~ /-(java|x86|x64|mingw|mswin|arm|aarch|darwin|linux|musl|freebsd)/i ||
            v =~ /\b(alpha|beta|rc|pre|dev|snapshot)\b/i ||
            v =~ /\.(alpha|beta|rc|pre|dev)\d*/i ||
            v =~ /[a-zA-Z]/ # any letters = prerelease
        end

        sorted = stable.uniq.sort_by { |v| Gem::Version.new(v) rescue Gem::Version.new("0") }
        result[name] = sorted.last(max_versions)
      end

      result
    end

    def self.api_get(url)
      retries = 0
      loop do
        begin
          resp = Net::HTTP.get_response(URI(url))
          if resp.code == "429"
            wait = (resp["retry-after"] || "2").to_i + 1
            $stderr.puts "\n  Rate limited, waiting #{wait}s..."
            sleep wait
            next
          end
          raise "HTTP #{resp.code} for #{url}" unless resp.code == "200"
          return JSON.parse(resp.body)
        rescue => e
          retries += 1
          raise if retries > 3
          $stderr.puts "\n  Retry #{retries}: #{e.message}"
          sleep 2 * retries
        end
      end
    end

    def self.http_get(url)
      uri = URI(url)
      resp = Net::HTTP.start(uri.host, uri.port, use_ssl: true,
                             open_timeout: 30, read_timeout: 120) do |http|
        http.request(Net::HTTP::Get.new(uri))
      end
      raise "HTTP #{resp.code} for #{url}" unless resp.code == "200"
      resp.body
    end
  end
end

# ── Dispatch ──────────────────────────────────────────────────────

adapter = case index
          when "rubygems" then Index::RubyGems
          else abort "Unknown index: #{index}. Supported: rubygems"
          end

$stderr.puts "Fetching top #{top_n} gems from #{index} (max #{max_versions} versions each)..."
result = adapter.fetch_top(top_n, max_versions)

names    = result[:names]
versions = result[:versions]

# ── Build gemset lines ────────────────────────────────────────────

lines = []
names.each do |name|
  vers = versions[name]
  next unless vers && !vers.empty?
  vers.each { |v| lines << "#{name} #{v}" }
end

$stderr.puts "#{lines.size} gem-version pairs from #{versions.size} gems"

# ── Write .gemset ─────────────────────────────────────────────────

FileUtils.mkdir_p(IMPORTS)
gemset_path = File.join(IMPORTS, "#{gemset_name}.gemset")
File.write(gemset_path, lines.join("\n") + "\n")
$stderr.puts "-> #{gemset_path}"

exit 0 if dry_run

# ── Fetch + Generate ──────────────────────────────────────────────

$stderr.puts "\nFetching gem sources..."
system(File.join(ROOT, "bin", "fetch"), gemset_path) || abort("fetch failed")

$stderr.puts "\nGenerating nix derivations..."
system(File.join(ROOT, "bin", "generate")) || abort("generate failed")

$stderr.puts "\nDone. #{lines.size} gem versions ready in nix/gem/"
