#!/usr/bin/env ruby
# frozen_string_literal: false

# scint-to-nix generate
#
# Reads a Gemfile.lock + scint cache -> writes nix derivation tree.
#
# Per-gem output:
#   default.nix  - always overwritten by generate (DO NOT EDIT)
#   compile.nix  - manual overrides, never overwritten. Only created for
#                  gems that need native compilation.
#
# Usage:
#   generate --lockfile path/to/Gemfile.lock --output out/gems/

require "json"
require "yaml"
require "fileutils"
require "rubygems/package"
require "stringio"
require "zlib"

SCINT_LIB = File.expand_path("../../scint/lib", __dir__)
$LOAD_PATH.unshift(SCINT_LIB)
require "scint/lockfile/parser"
require "scint/cache/layout"
require "scint/spec_utils"
require "scint/platform"

# Gems provided by Ruby itself — filter these from dependency lists.
RUBY_PROVIDED = %w[bundler rubygems].freeze

# Known native build inputs for gems that need system libraries.
# Loaded from native-deps.yml (project default) with optional per-project override.
def load_native_deps(*paths)
  merged = {}
  paths.each do |path|
    next unless path && File.exist?(path)
    data = YAML.safe_load(File.read(path)) || {}
    data.each { |gem, deps| merged[gem] = Array(deps) }
  end
  merged.freeze
end

GENERATED_HEADER = "# AUTO-GENERATED by scint-to-nix/bin/generate -- DO NOT EDIT\n# Edit compile.nix for build overrides.\n".freeze

def header
  GENERATED_HEADER.dup
end

# -- CLI -------------------------------------------------------------------

lockfile_path    = nil
output_dir       = nil
cache_root       = nil
extra_native_deps = nil

i = 0
while i < ARGV.length
  case ARGV[i]
  when "--lockfile",    "-l" then lockfile_path    = ARGV[i += 1]
  when "--output",      "-o" then output_dir       = ARGV[i += 1]
  when "--cache",       "-c" then cache_root       = ARGV[i += 1]
  when "--native-deps", "-n" then extra_native_deps = ARGV[i += 1]
  when "--help",        "-h"
    $stderr.puts "Usage: generate -l Gemfile.lock -o out/gems/ [-c cache_root] [-n native-deps.yml]"
    exit 0
  else abort "Unknown option: #{ARGV[i]}"
  end
  i += 1
end

abort "Missing --lockfile" unless lockfile_path
abort "Missing --output"   unless output_dir

# -- Load native deps config -----------------------------------------------

default_native_deps = File.join(File.expand_path("..", __dir__), "native-deps.yml")
NATIVE_DEPS = load_native_deps(default_native_deps, extra_native_deps)

# -- Resolve gems ----------------------------------------------------------

cache    = Scint::Cache::Layout.new(root: cache_root)
abi      = Scint::Platform.abi_key
lockfile = Scint::Lockfile::Parser.parse(lockfile_path)

# Filter to current platform, deduplicate (prefer platform-specific)
# Skip PATH-sourced gems — they're the project's own code, not third-party deps.
path_skipped = []
by_name = {}
lockfile.specs.each do |spec|
  next unless Scint::Platform.match_platform?(spec[:platform])
  if spec[:source].is_a?(Scint::Source::Path)
    path_skipped << spec[:name]
    next
  end
  name = spec[:name]
  prev = by_name[name]
  if prev.nil? || (spec[:platform] != "ruby" && prev[:platform] == "ruby")
    by_name[name] = spec
  end
end
unless path_skipped.empty?
  $stderr.puts "Skipped #{path_skipped.size} PATH-sourced gem(s): #{path_skipped.join(", ")}"
end

gems = by_name.values.map do |spec|
  name     = spec[:name]
  version  = spec[:version]
  platform = spec[:platform] || "ruby"
  full_name = Scint::SpecUtils.full_name_for(name, version, platform)

  cached_dir    = cache.cached_path(spec, abi)
  manifest_path = cache.cached_manifest_path(spec, abi)

  # Read real gemspec from spec.marshal if available
  spec_marshal_path = cached_dir + ".spec.marshal"
  real_spec = nil
  if File.exist?(spec_marshal_path)
    real_spec = Marshal.load(File.binread(spec_marshal_path)) rescue nil
  end

  # Detect extensions from manifest
  needs_ext = false
  if File.exist?(manifest_path)
    manifest = JSON.parse(File.read(manifest_path, encoding: "UTF-8"))
    needs_ext = manifest.dig("build", "extensions") == true
  end

  # In Nix, prebuilt .so from scint's cache won't work (wrong Ruby, wrong libs).
  # Every gem with extensions must be compiled from source inside the sandbox.
  needs_compilation = needs_ext

  # Detect nested source dir (monorepo pattern: cached/activesupport-8.2.0.alpha/activesupport/lib/)
  source_subdir = nil
  if Dir.exist?(cached_dir)
    unless Dir.exist?(File.join(cached_dir, "lib"))
      candidate = File.join(cached_dir, name)
      if Dir.exist?(candidate) && Dir.exist?(File.join(candidate, "lib"))
        source_subdir = name
      end
    end
  end

  # Detect extconf.rb paths for native gems
  extconfs = []
  if needs_compilation && Dir.exist?(cached_dir)
    extconfs = Dir.glob(File.join(cached_dir, "ext", "**", "extconf.rb"))
      .map { |p| p.sub("#{cached_dir}/", "") }
  end

  # require_paths: prefer spec.marshal, fall back to .gem YAML metadata, then ["lib"]
  require_paths = nil
  require_paths = real_spec.require_paths if real_spec

  unless require_paths
    gem_path = cache.inbound_path(spec)
    if File.exist?(gem_path)
      begin
        File.open(gem_path, "rb") do |io|
          Gem::Package::TarReader.new(io) do |tar|
            tar.each do |entry|
              if entry.full_name == "metadata.gz"
                yaml = Zlib::GzipReader.new(StringIO.new(entry.read)).read
                meta = YAML.safe_load(yaml,
                  permitted_classes: [Gem::Specification, Gem::Version, Gem::Requirement, Gem::Dependency, Symbol, Time])
                require_paths = meta.require_paths rescue meta["require_paths"] rescue nil
                break
              end
            end
          end
        end
      rescue => e
        $stderr.puts "WARN: #{full_name}: could not read .gem metadata: #{e.message}"
      end
    end
  end

  require_paths ||= ["lib"]

  # Verify require_paths exist; empty for meta-gems (rails, rubocop-rails-omakase)
  if Dir.exist?(cached_dir) || source_subdir
    base = source_subdir ? File.join(cached_dir, source_subdir) : cached_dir
    require_paths = require_paths.select { |p| Dir.exist?(File.join(base, p)) }
  end

  # Executables: prefer spec.marshal (if populated), fall back to .gem YAML metadata
  executables = nil
  bindir = nil
  if real_spec && real_spec.respond_to?(:executables) && !real_spec.executables.empty?
    executables = real_spec.executables
    bindir = real_spec.bindir
  end

  if executables.nil? || executables.empty?
    gem_path = cache.inbound_path(spec)
    if File.exist?(gem_path)
      begin
        File.open(gem_path, "rb") do |io|
          Gem::Package::TarReader.new(io) do |tar|
            tar.each do |entry|
              if entry.full_name == "metadata.gz"
                yaml = Zlib::GzipReader.new(StringIO.new(entry.read)).read
                meta = YAML.safe_load(yaml,
                  permitted_classes: [Gem::Specification, Gem::Version, Gem::Requirement, Gem::Dependency, Symbol, Time])
                executables = meta.executables rescue nil
                bindir = meta.bindir rescue nil
                break
              end
            end
          end
        end
      rescue => e
        # ignore
      end
    end
  end

  executables ||= []
  bindir ||= "exe"

  nix_attr = full_name

  # Detect git source
  git_source = nil
  if spec[:source].is_a?(Scint::Source::Git)
    src = spec[:source]
    uri = src.uri
    base_name = File.basename(uri.sub(%r{^(\w+://)?([^/:]+:)?(//\w*/)?(\w*/)*}, ""), ".git")
    shortref = src.revision[0..11]
    git_source = {
      uri: uri,
      revision: src.revision,
      base_name: base_name,
      shortref: shortref,
      checkout_dir: "#{base_name}-#{shortref}",
    }
  end

  {
    name: name, version: version, platform: platform,
    full_name: full_name, nix_attr: nix_attr,
    deps: (spec[:dependencies] || []).map { |d| d[:name] }.reject { |d| RUBY_PROVIDED.include?(d) || path_skipped.include?(d) },
    cached: Dir.exist?(cached_dir), cached_dir: cached_dir,
    needs_compilation: needs_compilation,
    native_deps: needs_compilation ? (NATIVE_DEPS[name] || []) : [],
    source_subdir: source_subdir,
    extconfs: extconfs,
    require_paths: require_paths,
    executables: executables,
    bindir: bindir,
    git_source: git_source,
  }
end

# Check all cached
missing = gems.reject { |g| g[:cached] }
if missing.any?
  $stderr.puts "ERROR: #{missing.size} gems not in scint cache:"
  missing.each { |g| $stderr.puts "  #{g[:full_name]}" }
  $stderr.puts "\nRun: scint cache add --lockfile #{lockfile_path}"
  exit 1
end

# -- Generate per-gem dirs -------------------------------------------------

output_dir = File.expand_path(output_dir)
FileUtils.mkdir_p(output_dir)

name_to_attr = {}
gems.each { |g| name_to_attr[g[:name]] = g[:nix_attr] }

generated = 0
copied    = 0

gems.each do |g|
  dir = File.join(output_dir, g[:nix_attr])
  source_dir = File.join(dir, "source")

  # Always copy source if missing
  unless Dir.exist?(source_dir)
    FileUtils.mkdir_p(dir)
    if g[:source_subdir]
      FileUtils.cp_r(File.join(g[:cached_dir], g[:source_subdir]), source_dir)
    else
      FileUtils.cp_r(g[:cached_dir], source_dir)
    end

    # Strip pre-built .so/.bundle from scint's cache — they're linked against
    # the wrong Ruby/system libs and must be recompiled inside the Nix sandbox.
    if g[:needs_compilation]
      Dir.glob(File.join(source_dir, "lib", "**", "*.{so,bundle}")).each do |f|
        File.delete(f)
      end
    end

    copied += 1
  end

  name    = g[:name]
  version = g[:version]

  # -- compile.nix (never overwritten) --
  compile_nix_path = File.join(dir, "compile.nix")
  if g[:needs_compilation] && !File.exist?(compile_nix_path)
    cnix = "# compile.nix for #{name} #{version}\n"
    cnix << "#\n"
    cnix << "# Override build behaviour here. This file is never overwritten by generate.\n"
    cnix << "# default.nix imports this and merges the attrs below.\n"
    cnix << "#\n"
    cnix << "# extconf.rb locations found in source:\n"
    g[:extconfs].each { |e| cnix << "#   #{e}\n" }
    cnix << "#\n"
    cnix << "# Known native deps: #{g[:native_deps].inspect}\n"
    cnix << "{\n"
    cnix << "  nativeBuildInputs = [];\n"
    cnix << "  preBuild = \"\";\n"
    cnix << "  postBuild = \"\";\n"
    cnix << "  preInstall = \"\";\n"
    cnix << "  postInstall = \"\";\n"
    cnix << "}\n"
    File.write(compile_nix_path, cnix)
  end

  # -- default.nix (always overwritten) --

  nix = header
  nix << "# #{name} #{version}\n"

  if g[:needs_compilation]
    args = %w[lib stdenv ruby]
    args.concat(g[:native_deps])
    args << "scintGemDeps ? {}"
    nix << "{ #{args.join(", ")} }:\n\n"
    nix << "let\n"
    nix << "  compile = import ./compile.nix;\n"
    nix << "in\n\n"
    nix << "stdenv.mkDerivation {\n"
    nix << "  pname = \"#{name}\";\n"
    nix << "  version = \"#{version}\";\n"
    nix << "  src = ./source;\n\n"

    native = (["ruby"] + g[:native_deps]).join(" ")
    nix << "  nativeBuildInputs = [ #{native} ] ++ compile.nativeBuildInputs;\n\n"

    nix << "  buildPhase = ''\n"
    nix << "    ${compile.preBuild}\n"
    nix << "    for extconf in $(find ext -name extconf.rb 2>/dev/null); do\n"
    nix << "      dir=$(dirname \"$extconf\")\n"
    nix << "      echo \"Building extension in $dir\"\n"
    nix << "      (cd \"$dir\" && ruby extconf.rb && make -j$NIX_BUILD_CORES)\n"
    nix << "    done\n"
    nix << "    for makefile in $(find ext -name Makefile 2>/dev/null); do\n"
    nix << "      dir=$(dirname \"$makefile\")\n"
    nix << "      target_name=$(sed -n 's/^TARGET = //p' \"$makefile\")\n"
    nix << "      target_prefix=$(sed -n 's/^target_prefix = //p' \"$makefile\")\n"
    nix << "      if [ -n \"$target_name\" ] && [ -f \"$dir/$target_name.so\" ]; then\n"
    nix << "        mkdir -p \"lib$target_prefix\"\n"
    nix << "        cp \"$dir/$target_name.so\" \"lib$target_prefix/$target_name.so\"\n"
    nix << "        echo \"Installed $dir/$target_name.so -> lib$target_prefix/$target_name.so\"\n"
    nix << "      fi\n"
    nix << "    done\n"
    nix << "    ${compile.postBuild}\n"
    nix << "  '';\n\n"
  else
    args = %w[lib stdenv ruby]
    args << "scintGemDeps ? {}"
    nix << "{ #{args.join(", ")} }:\n\n"
    nix << "stdenv.mkDerivation {\n"
    nix << "  pname = \"#{name}\";\n"
    nix << "  version = \"#{version}\";\n"
    nix << "  src = ./source;\n\n"
    nix << "  dontBuild = true;\n"
  end

  nix << "  dontConfigure = true;\n\n"

  unless g[:deps].empty?
    nix << "  propagatedBuildInputs = [\n"
    g[:deps].each { |d| nix << "    (scintGemDeps.\"#{d}\" or null)\n" }
    nix << "  ];\n\n"
  end

  nix << "  installPhase = ''\n"
  if g[:needs_compilation]
    nix << "    ${compile.preInstall}\n"
  end
  # Use full_name for dirs/files (includes platform suffix for platform gems)
  gem_full_name = g[:platform] == "ruby" ? "#{name}-#{version}" : "#{name}-#{version}-#{g[:platform]}"
  nix << "    mkdir -p $out/gems/#{gem_full_name}\n"
  nix << "    cp -r . $out/gems/#{gem_full_name}/\n"
  nix << "    mkdir -p $out/specifications\n"
  nix << "    cat > $out/specifications/#{gem_full_name}.gemspec <<'GEMSPEC'\n"
  nix << "    Gem::Specification.new do |s|\n"
  nix << "      s.name = \"#{name}\"\n"
  nix << "      s.version = \"#{version}\"\n"
  if g[:platform] != "ruby"
    nix << "      s.platform = \"#{g[:platform]}\"\n"
  end
  nix << "      s.summary = \"#{name}\"\n"
  nix << "      s.require_paths = [#{g[:require_paths].map { |p| "\"#{p}\"" }.join(", ")}]\n"
  unless g[:executables].empty?
    nix << "      s.bindir = \"#{g[:bindir]}\"\n"
    nix << "      s.executables = [#{g[:executables].map { |e| "\"#{e}\"" }.join(", ")}]\n"
  end
  nix << "      s.files = []\n"
  g[:deps].each { |d| nix << "      s.add_dependency \"#{d}\"\n" }
  nix << "    end\n"
  nix << "    GEMSPEC\n"
  if g[:needs_compilation]
    nix << "    ${compile.postInstall}\n"
  end
  nix << "  '';\n"
  nix << "}\n"

  File.write(File.join(dir, "default.nix"), nix)
  generated += 1
end

# -- top-level default.nix (always regenerated) ----------------------------

nix = header
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\nlet\n  scintGems = {\n"

gems.each do |g|
  nix << "\n    \"#{g[:nix_attr]}\" = pkgs.callPackage ./#{g[:nix_attr]} {\n"
  nix << "      inherit ruby;\n"
  dep_entries = g[:deps].filter_map do |d|
    attr = name_to_attr[d]
    attr ? "          { name = \"#{d}\"; value = scintGems.\"#{attr}\" or null; }" : nil
  end
  unless dep_entries.empty?
    nix << "      scintGemDeps = builtins.listToAttrs (\n"
    nix << "        builtins.filter (x: x.value != null) [\n"
    nix << dep_entries.join("\n") << "\n"
    nix << "        ]\n"
    nix << "      );\n"
  end
  nix << "    };\n"
end

nix << "\n  };\nin scintGems\n"
File.write(File.join(output_dir, "default.nix"), nix)

# -- Git checkout derivations (for monorepo git sources) -------------------

rubygems_gems = gems.reject { |g| g[:git_source] }
git_gems = gems.select { |g| g[:git_source] }

# Group git gems by checkout dir
git_checkouts = {}
git_gems.each do |g|
  dir = g[:git_source][:checkout_dir]
  git_checkouts[dir] ||= { gems: [], source: g[:git_source] }
  git_checkouts[dir][:gems] << g
end

# For each git checkout, create a source dir and derivation with the full repo source
git_checkouts.each do |checkout_dir, info|
  checkout_out_dir = File.join(output_dir, "_git_#{checkout_dir}")
  source_dir = File.join(checkout_out_dir, "source")

  unless Dir.exist?(source_dir)
    FileUtils.mkdir_p(source_dir)
    # Merge all cached dirs from all gems in this git checkout.
    # For monorepos (rails, azure-storage-ruby), each sub-gem's cached dir
    # may only contain its own slice. We overlay them all into one tree.
    info[:gems].each do |g|
      Dir.children(g[:cached_dir]).each do |child|
        src = File.join(g[:cached_dir], child)
        dst = File.join(source_dir, child)
        FileUtils.cp_r(src, dst) unless File.exist?(dst)
      end
    end
    $stderr.puts "  Merged git checkout: #{checkout_dir} from #{info[:gems].size} gem(s)"
  end

  # Write default.nix — simple copy, no build
  nix = header
  nix << "# Git checkout: #{checkout_dir}\n"
  nix << "{ lib, stdenv }:\n\n"
  nix << "stdenv.mkDerivation {\n"
  nix << "  pname = \"git-checkout-#{checkout_dir}\";\n"
  nix << "  version = \"0.0.1\";\n"
  nix << "  src = ./source;\n"
  nix << "  dontBuild = true;\n"
  nix << "  dontConfigure = true;\n"
  nix << "  installPhase = ''\n"
  nix << "    mkdir -p $out\n"
  nix << "    cp -r . $out/\n"
  nix << "  '';\n"
  nix << "}\n"
  File.write(File.join(checkout_out_dir, "default.nix"), nix)
end

# -- bundle-path.nix (always regenerated) ---------------------------------
nix = header
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\nlet\n"
nix << "  scintGems = import ./default.nix { inherit pkgs ruby; };\n"
nix << "  rubyApiVersion = ruby.version.major + \".\" + ruby.version.minor + \".0\";\n"

# Import git checkout derivations
git_checkouts.each do |checkout_dir, _|
  nix << "  gitCheckout_#{checkout_dir.gsub("-", "_")} = pkgs.callPackage ./_git_#{checkout_dir} {};\n"
end

nix << "in pkgs.stdenv.mkDerivation {\n"
nix << "  pname = \"scint-bundle-path\";\n"
nix << "  version = \"0.0.1\";\n"
nix << "  dontUnpack = true;\n  dontBuild = true;\n  dontConfigure = true;\n\n"
nix << "  installPhase = ''\n"
nix << "    prefix=$out/ruby/${rubyApiVersion}\n"
nix << "    mkdir -p $prefix/gems $prefix/specifications $prefix/bundler/gems\n\n"

# Rubygems-sourced: symlink into ruby/<ver>/gems/ + ruby/<ver>/specifications/
nix << "    # Rubygems-sourced gems\n"
rubygems_gems.each do |g|
  full = g[:platform] == "ruby" ? "#{g[:name]}-#{g[:version]}" : "#{g[:name]}-#{g[:version]}-#{g[:platform]}"
  nix << "    ln -s ${scintGems.\"#{g[:nix_attr]}\"}/gems/#{full} $prefix/gems/#{full}\n"
  nix << "    ln -s ${scintGems.\"#{g[:nix_attr]}\"}/specifications/#{full}.gemspec $prefix/specifications/#{full}.gemspec\n"
end

# Git-sourced: symlink full checkout dirs at ruby/<ver>/bundler/gems/<base>-<shortref>/
nix << "\n    # Git-sourced gem checkouts (full repo source)\n"
git_checkouts.each do |checkout_dir, _|
  nix_var = "gitCheckout_#{checkout_dir.gsub("-", "_")}"
  nix << "    ln -s ${#{nix_var}} $prefix/bundler/gems/#{checkout_dir}\n"
end

# Gem binstubs in ruby/<ver>/bin/
gems_with_exes = gems.select { |g| !g[:executables].empty? }
unless gems_with_exes.empty?
  nix << "\n    # Gem binstubs\n"
  nix << "    mkdir -p $prefix/bin\n"
  gems_with_exes.each do |g|
    full = g[:platform] == "ruby" ? "#{g[:name]}-#{g[:version]}" : "#{g[:name]}-#{g[:version]}-#{g[:platform]}"
    g[:executables].each do |exe|
      if g[:git_source]
        checkout_dir = g[:git_source][:checkout_dir]
        nix_var = "gitCheckout_#{checkout_dir.gsub("-", "_")}"
        # Git gems: exe is relative to the checkout subdir
        source_subdir = g[:source_subdir]
        if source_subdir
          nix << "    ln -sf ${#{nix_var}}/#{source_subdir}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
        else
          nix << "    ln -sf ${#{nix_var}}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
        end
      else
        nix << "    ln -sf ${scintGems.\"#{g[:nix_attr]}\"}/gems/#{full}/#{g[:bindir]}/#{exe} $prefix/bin/#{exe}\n"
      end
    end
  end
end

nix << "  '';\n}\n"
File.write(File.join(output_dir, "bundle-path.nix"), nix)

# -- gemset.json (always regenerated) -------------------------------------

File.write(File.join(output_dir, "gemset.json"), JSON.pretty_generate(
  gems.map { |g|
    h = { name: g[:name], version: g[:version], platform: g[:platform],
          nix_attr: g[:nix_attr], deps: g[:deps],
          needs_compilation: g[:needs_compilation], native_deps: g[:native_deps],
          require_paths: g[:require_paths] }
    h[:source_subdir] = g[:source_subdir] if g[:source_subdir]
    h[:extconfs] = g[:extconfs] if g[:extconfs] && !g[:extconfs].empty?
    h[:git_source] = g[:git_source] if g[:git_source]
    h
  }
))

# -- <name>.deps.nix (always regenerated) ----------------------------------
# A flat list of all gem derivations, importable as a dependency list.

project_name = File.basename(File.dirname(File.expand_path(lockfile_path)))
nix = header
nix << "# All #{gems.size} gems from #{project_name}/Gemfile.lock\n"
nix << "{ pkgs ? import <nixpkgs> {}, ruby ? pkgs.ruby }:\n\n"
nix << "let\n"
nix << "  gems = import ./default.nix { inherit pkgs ruby; };\n"
nix << "in [\n"
gems.sort_by { |g| g[:name] }.each do |g|
  nix << "  gems.\"#{g[:nix_attr]}\"\n"
end
nix << "]\n"
File.write(File.join(output_dir, "#{project_name}.deps.nix"), nix)

$stdout.puts "#{generated} generated (#{copied} sources copied). #{gems.size} total."
