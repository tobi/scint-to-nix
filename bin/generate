#!/usr/bin/env ruby
# frozen_string_literal: true

# generate — build per-gem Nix derivations from fetched gem cache
#
# Each gem: nix/gem/<name>/<version>/default.nix
# If overlays/<name>.nix exists, it's imported for extra nativeBuildInputs
# and optional buildPhase override.
#
# All gems use plain names (e.g. sqlite3-2.8.0). Platform-qualified aliases
# (e.g. sqlite3-2.8.0-x86_64-linux-gnu) are created by the gemset generator
# for gems that need them.
#
# Usage:
#   generate              — generate from all cached gems
#   generate -o nix/gem/ — custom output dir

require "json"
require "fileutils"

CACHE_DIR    = File.join(__dir__, "..", "cache")
SOURCE_DIR   = File.join(CACHE_DIR, "sources")
META_DIR     = File.join(CACHE_DIR, "meta")
OVERLAYS_DIR = File.join(__dir__, "..", "overlays")

output_dir = File.join(__dir__, "..", "nix", "gem")

i = 0
while i < ARGV.length
  case ARGV[i]
  when "-o", "--output" then output_dir = ARGV[i += 1]
  when "-h", "--help"
    $stderr.puts "Usage: generate [-o nix/gem/]"
    exit 0
  else abort "Unknown option: #{ARGV[i]}"
  end
  i += 1
end

output_dir = File.expand_path(output_dir)
FileUtils.mkdir_p(output_dir)

# Which gems have overlays?
overlays = {}
if Dir.exist?(OVERLAYS_DIR)
  Dir.glob(File.join(OVERLAYS_DIR, "*.nix")).each do |f|
    overlays[File.basename(f, ".nix")] = true
  end
end

# -- Load all metadata -----------------------------------------------------

meta_by_key = {}
Dir.glob(File.join(META_DIR, "*.json")).each do |f|
  m = JSON.parse(File.read(f), symbolize_names: true)
  meta_by_key["#{m[:name]}-#{m[:version]}"] = m
end

$stderr.puts "#{meta_by_key.size} gems in cache (#{overlays.size} overlays)"

# -- Helper: indented heredoc content for nixfmt ---------------------------
#
# nixfmt wants shell lines at 4 spaces, heredoc body at 0 spaces, and
# heredoc terminator at 0 spaces (relative to Nix ''..'' baseline).
# Since nix strips the minimum indent, we emit:
#   - shell lines at 8 spaces (becomes 4 in bash)
#   - heredoc body at 4 spaces (becomes 0 in bash)
#   - heredoc terminator at 4 spaces (becomes 0 in bash)
#
SH  = "        "  # 8 spaces — shell commands
HD  = "    "      # 4 spaces — heredoc body / terminator
CL  = "  "        # 2 spaces — '' closer

# -- Per-gem derivations ---------------------------------------------------

generated = 0

meta_by_key.each_value do |meta|
  name    = meta[:name]
  version = meta[:version]
  key     = "#{name}-#{version}"

  source_dir = File.join(SOURCE_DIR, key)
  next unless Dir.exist?(source_dir)

  has_ext       = meta[:has_extensions] || !Dir.glob(File.join(source_dir, "ext", "**", "extconf.rb")).empty?
  require_paths = meta[:require_paths] || ["lib"]
  executables   = meta[:executables] || []
  bindir        = meta[:bindir] || "exe"

  # Verify require_paths exist
  verified = require_paths.select { |p| Dir.exist?(File.join(source_dir, p)) }
  require_paths = verified unless verified.empty?

  gem_dir = File.join(output_dir, name, version)
  FileUtils.mkdir_p(gem_dir)
  FileUtils.ln_sf(source_dir, File.join(gem_dir, "source"))

  has_overlay = overlays.key?(name)
  has_heredoc = true  # installPhase always has gemspec heredoc

  # Pick indent: 4 spaces if no heredoc in block, 8 if heredoc present
  si = has_heredoc ? SH : "    "

  nix = +""
  nix << "#\n"
  nix << "# ╔══════════════════════════════════════════════════════════════╗\n"
  nix << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
  nix << "# ╚══════════════════════════════════════════════════════════════╝\n"
  nix << "#\n"
  nix << "# #{name} #{version}\n"
  nix << "#\n"

  args = ["lib", "stdenv", "ruby"]
  args << "pkgs" if has_overlay
  nix << "{\n"
  args.each { |a| nix << "  #{a},\n" }
  nix << "}:\n"

  nix << "let\n"
  nix << "  rubyVersion = \"${ruby.version.majMin}.0\";\n"
  nix << "  arch = stdenv.hostPlatform.system;\n"
  nix << "  prefix = \"ruby/${rubyVersion}\";\n"

  if has_overlay
    nix << "  overlay = import ../../../../overlays/#{name}.nix { inherit pkgs ruby; };\n"
    nix << "  overlayDeps = if builtins.isList overlay then overlay else overlay.deps or [ ];\n"
    nix << "  overlayBuildPhase =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? buildPhase then overlay.buildPhase else null;\n"
    nix << "  overlayBeforeBuild =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? beforeBuild then overlay.beforeBuild else \"\";\n"
    nix << "  overlayAfterBuild =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? afterBuild then overlay.afterBuild else \"\";\n"
    nix << "  overlayPostInstall =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? postInstall then overlay.postInstall else \"\";\n"
    nix << "  overlayExtconfFlags =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? extconfFlags then overlay.extconfFlags else \"\";\n"
  end

  nix << "in\n"
  nix << "stdenv.mkDerivation {\n"
  nix << "  pname = \"#{name}\";\n"
  nix << "  version = \"#{version}\";\n"
  nix << "  src = builtins.path {\n"
  nix << "    path = ./source;\n"
  nix << "    name = \"#{key}-source\";\n"
  nix << "  };\n\n"

  if has_ext
    # Default build: find all extconf.rb, build each, copy .so to lib/
    default_build_lines = [
      "for extconf in $(find ext -name extconf.rb 2>/dev/null); do",
      "  dir=$(dirname \"$extconf\")",
      "  echo \"Building extension in $dir\"",
      "  (cd \"$dir\" && ruby extconf.rb $extconfFlags && make -j$NIX_BUILD_CORES)",
      "done",
      "for makefile in $(find ext -name Makefile 2>/dev/null); do",
      "  dir=$(dirname \"$makefile\")",
      "  target_name=$(sed -n 's/^TARGET = //p' \"$makefile\")",
      "  target_prefix=$(sed -n 's/^target_prefix = //p' \"$makefile\")",
      "  if [ -n \"$target_name\" ] && [ -f \"$dir/$target_name.so\" ]; then",
      "    mkdir -p \"lib$target_prefix\"",
      "    cp \"$dir/$target_name.so\" \"lib$target_prefix/$target_name.so\"",
      "    echo \"Installed $dir/$target_name.so -> lib$target_prefix/$target_name.so\"",
      "  fi",
      "done",
    ]
    if has_overlay
      nix << "  nativeBuildInputs = [ ruby ] ++ overlayDeps;\n\n"
      nix << "  buildPhase =\n"
      nix << "    if overlayBuildPhase != null then\n"
      nix << "      overlayBuildPhase\n"
      nix << "    else\n"
      nix << "      ''\n"
      nix << "        extconfFlags=\"${overlayExtconfFlags}\"\n"
      nix << "        ${overlayBeforeBuild}\n"
      default_build_lines.each { |l| nix << "        #{l}\n" }
      nix << "        ${overlayAfterBuild}\n"
      nix << "      '';\n\n"
    else
      nix << "  nativeBuildInputs = [ ruby ];\n\n"
      nix << "  buildPhase = ''\n"
      nix << "    extconfFlags=\"\"\n"
      default_build_lines.each { |l| nix << "    #{l}\n" }
      nix << "  '';\n\n"
    end
  else
    nix << "  dontBuild = true;\n"
  end

  nix << "  dontConfigure = true;\n\n"
  nix << "  passthru = { inherit prefix; };\n\n"

  nix << "  installPhase = ''\n"
  nix << "#{si}local dest=$out/${prefix}\n"
  nix << "#{si}mkdir -p $dest/gems/#{key}\n"
  nix << "#{si}cp -r . $dest/gems/#{key}/\n"

  if has_ext
    nix << "#{si}local extdir=$dest/extensions/${arch}/${rubyVersion}/#{key}\n"
    nix << "#{si}mkdir -p $extdir\n"
    nix << "#{si}find . -name '*.so' -path '*/lib/*' | while read so; do\n"
    nix << "#{si}  cp \"$so\" \"$extdir/\"\n"
    nix << "#{si}done\n"
    nix << "#{si}local gp=\"${stdenv.hostPlatform.parsed.cpu.name}-${stdenv.hostPlatform.parsed.kernel.name}\"\n"
    nix << "#{si}if [ \"${stdenv.hostPlatform.parsed.abi.name}\" != \"unknown\" ]; then\n"
    nix << "#{si}  gp=\"$gp-${stdenv.hostPlatform.parsed.abi.name}\"\n"
    nix << "#{si}fi\n"
    nix << "#{si}ln -s #{key} $dest/gems/#{key}-$gp\n"
    nix << "#{si}ln -s #{key} $dest/extensions/${arch}/${rubyVersion}/#{key}-$gp\n"
  end

  nix << "#{si}mkdir -p $dest/specifications\n"
  nix << "#{si}cat > $dest/specifications/#{key}.gemspec <<'EOF'\n"
  nix << "#{HD}Gem::Specification.new do |s|\n"
  nix << "#{HD}  s.name = \"#{name}\"\n"
  nix << "#{HD}  s.version = \"#{version}\"\n"
  nix << "#{HD}  s.summary = \"#{name}\"\n"
  nix << "#{HD}  s.require_paths = [#{require_paths.map { |p| "\"#{p}\"" }.join(", ")}]\n"
  unless executables.empty?
    nix << "#{HD}  s.bindir = \"#{bindir}\"\n"
    nix << "#{HD}  s.executables = [#{executables.map { |e| "\"#{e}\"" }.join(", ")}]\n"
  end
  nix << "#{HD}  s.files = []\n"
  nix << "#{HD}end\n"
  nix << "#{HD}EOF\n"

  if has_ext
    rp_str = require_paths.map { |p| "\"#{p}\"" }.join(", ")
    nix << "#{si}cat > $dest/specifications/#{key}-$gp.gemspec <<PLATSPEC\n"
    nix << "#{HD}Gem::Specification.new do |s|\n"
    nix << "#{HD}  s.name = \"#{name}\"\n"
    nix << "#{HD}  s.version = \"#{version}\"\n"
    nix << "#{HD}  s.platform = \"$gp\"\n"
    nix << "#{HD}  s.summary = \"#{name}\"\n"
    nix << "#{HD}  s.require_paths = [#{rp_str}]\n"
    unless executables.empty?
      nix << "#{HD}  s.bindir = \"#{bindir}\"\n"
      nix << "#{HD}  s.executables = [#{executables.map { |e| "\"#{e}\"" }.join(", ")}]\n"
    end
    nix << "#{HD}  s.files = []\n"
    nix << "#{HD}end\n"
    nix << "#{HD}PLATSPEC\n"
  end

  unless executables.empty?
    nix << "#{si}mkdir -p $dest/bin\n"
    executables.each do |exe|
      nix << "#{si}cat > $dest/bin/#{exe} <<'BINSTUB'\n"
      nix << "#{HD}#!/usr/bin/env ruby\n"
      nix << "#{HD}require \"rubygems\"\n"
      nix << "#{HD}load Gem.bin_path(\"#{name}\", \"#{exe}\", \"#{version}\")\n"
      nix << "#{HD}BINSTUB\n"
      nix << "#{si}chmod +x $dest/bin/#{exe}\n"
    end
  end

  if has_overlay
    nix << "#{si}${overlayPostInstall}\n"
  end
  nix << "  '';\n"
  nix << "}\n"

  File.write(File.join(gem_dir, "default.nix"), nix)
  generated += 1
end

$stderr.puts "#{generated} derivations"

# -- Per-gem selector: nix/gem/<name>/default.nix -------------------------
#
# Groups all versions (and later git refs, added by generate-gemset) into a
# selector that supports:
#
#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };
#   gems.rails { version = "7.1.5.2"; }
#   gems.rails { git.rev = "60d92e4e7dfe"; }

gems_by_name = {}
meta_by_key.each_value do |meta|
  name = meta[:name]
  version = meta[:version]
  source_dir = File.join(SOURCE_DIR, "#{name}-#{version}")
  next unless Dir.exist?(source_dir)
  (gems_by_name[name] ||= { versions: [], has_overlay: overlays.key?(name) })[:versions] << version
end

gems_by_name.each do |name, info|
  versions = info[:versions].sort_by { |v| Gem::Version.new(v) }
  has_overlay = info[:has_overlay]
  latest = versions.last

  sel = +""
  sel << "#\n"
  sel << "# ╔══════════════════════════════════════════════════════════════╗\n"
  sel << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
  sel << "# ╚══════════════════════════════════════════════════════════════╝\n"
  sel << "#\n"
  sel << "# #{name}\n"
  sel << "#\n"
  sel << "# Available versions:\n"
  versions.each { |v| sel << "#   #{v}\n" }
  sel << "#\n"
  sel << "# Usage:\n"
  sel << "#   #{name} { version = \"#{latest}\"; }\n"
  sel << "#   #{name} { }  # latest (#{latest})\n"
  sel << "#\n"
  sel << "{\n"
  sel << "  lib,\n"
  sel << "  stdenv,\n"
  sel << "  ruby,\n"
  sel << "  pkgs ? null,\n"
  sel << "  version ? \"#{latest}\",\n"
  sel << "  git ? { },\n"
  sel << "}:\n"
  sel << "let\n"

  sel << "  versions = {\n"
  versions.each do |v|
    if has_overlay
      sel << "    \"#{v}\" = import ./#{v} {\n"
      sel << "      inherit\n"
      sel << "        lib\n"
      sel << "        stdenv\n"
      sel << "        ruby\n"
      sel << "        pkgs\n"
      sel << "        ;\n"
      sel << "    };\n"
    else
      sel << "    \"#{v}\" = import ./#{v} { inherit lib stdenv ruby; };\n"
    end
  end
  sel << "  };\n\n"

  sel << "  gitRevs = {\n"
  # Populated by generate-gemset
  sel << "  };\n"

  sel << "in\n"
  sel << "if git ? rev then\n"
  sel << "  gitRevs.\${git.rev}\n"
  sel << "    or (throw \"#{name}: unknown git rev '\${git.rev}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\")\n"
  sel << "else\n"
  sel << "  versions.\${version}\n"
  sel << "    or (throw \"#{name}: unknown version '\${version}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames versions)}\")\n"

  File.write(File.join(output_dir, name, "default.nix"), sel)
end

$stderr.puts "#{gems_by_name.size} selectors"

# -- Top-level nix/gem/default.nix ---------------------------------------
#
# Exposes every gem as a callable selector:
#
#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };
#   gems.rails { version = "7.1.5.2"; }
#   gems.rails { git.rev = "60d92e4e7dfe"; }
#   gems.sqlite3 { version = "2.8.0"; }
#

top = +""
top << "#\n"
top << "# ╔══════════════════════════════════════════════════════════════╗\n"
top << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
top << "# ╚══════════════════════════════════════════════════════════════╝\n"
top << "#\n"
top << "# #{gems_by_name.size} gems\n"
top << "#\n"
top << "# Usage:\n"
top << "#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };\n"
top << "#   gems.rails { version = \"7.1.5.2\"; }\n"
top << "#   gems.rails { git.rev = \"60d92e4e7dfe\"; }\n"
top << "#   gems.rack {}  # latest\n"
top << "#\n"
top << "{ pkgs, ruby }:\n\n"
top << "let\n"
top << "  inherit (pkgs) lib stdenv;\n"
top << "  gem =\n"
top << "    name: args:\n"
top << "    import (../gem + \"/\${name}\") (\n"
top << "      {\n"
top << "        inherit\n"
top << "          lib\n"
top << "          stdenv\n"
top << "          ruby\n"
top << "          pkgs\n"
top << "          ;\n"
top << "      }\n"
top << "      // args\n"
top << "    );\n"
top << "in\n"
top << "{\n"

gems_by_name.keys.sort.each do |name|
  top << "  #{name.inspect} = args: gem #{name.inspect} args;\n"
end

top << "}\n"

modules_dir = File.join(output_dir, "..", "modules")
FileUtils.mkdir_p(modules_dir)
File.write(File.join(modules_dir, "gem.nix"), top)
$stderr.puts "-> nix/modules/gem.nix"
