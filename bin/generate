#!/usr/bin/env ruby
# frozen_string_literal: true

# generate — build per-gem Nix derivations from fetched gem cache
#
# Each gem: nix/gem/<name>/<version>/default.nix
# If overlays/<name>.nix exists, it's imported for extra nativeBuildInputs
# and optional buildPhase override.
#
# All gems use plain names (e.g. sqlite3-2.8.0). Platform-qualified aliases
# (e.g. sqlite3-2.8.0-x86_64-linux-gnu) are created by the gemset generator
# for gems that need them.
#
# Usage:
#   generate              — generate from all cached gems
#   generate -o nix/gem/ — custom output dir

require "json"
require "fileutils"

CACHE_DIR    = File.join(__dir__, "..", "cache")
SOURCE_DIR   = File.join(CACHE_DIR, "sources")
META_DIR     = File.join(CACHE_DIR, "meta")
OVERLAYS_DIR = File.join(__dir__, "..", "overlays")

output_dir = File.join(__dir__, "..", "nix", "gem")

# ── Auto-detection: library name → nixpkgs deps ──────────────────────────
#
# When a gem's extconf.rb calls pkg_config(), find_header(), or have_library()
# for a known library, we can infer the needed nativeBuildInputs automatically.
# This eliminates the need for a hand-written overlay in most cases.
#
# Manual overlays (overlays/<name>.nix) always win over auto-detection.

# Map: string found in pkg_config/find_header/have_library → nixpkgs attr names
LIB_TO_NIXPKGS = {
  # extconf string        => [nix attrs]
  "libffi"             => %w[libffi pkg-config],
  "ffi"                => %w[libffi pkg-config],
  "openssl"            => %w[openssl pkg-config],
  "libssl"             => %w[openssl pkg-config],
  "libcrypto"          => %w[openssl pkg-config],
  "ssl"                => %w[openssl pkg-config],
  "crypto"             => %w[openssl pkg-config],
  "yaml-0.1"           => %w[libyaml pkg-config],
  "yaml"               => %w[libyaml pkg-config],
  "yaml.h"             => %w[libyaml pkg-config],
  "sqlite3"            => %w[sqlite pkg-config],
  "libpq"              => %w[libpq pkg-config],
  "pq"                 => %w[libpq pkg-config],
  "z"                  => %w[zlib pkg-config],
  "zlib"               => %w[zlib pkg-config],
  "snappy"             => %w[snappy pkg-config],
  "libsnappy"          => %w[snappy pkg-config],
  "libxml2"            => %w[libxml2 pkg-config],
  "libxml-2.0"         => %w[libxml2 pkg-config],
  "libxslt"            => %w[libxslt pkg-config],
  "mysqlclient"        => %w[libmysqlclient openssl pkg-config zlib],
  "mysql"              => %w[libmysqlclient openssl pkg-config zlib],
  "libgit2"            => %w[cmake pkg-config openssl zlib libssh2],
  "re2"                => %w[re2 pkg-config],
  "icu"                => %w[icu zlib pkg-config],
  "icu-uc"             => %w[icu zlib pkg-config],
  "icu-i18n"           => %w[icu zlib pkg-config],
  "ImageMagick"        => %w[imagemagick pkg-config],
  "MagickWand"         => %w[imagemagick pkg-config],
  "pam"                => %w[pam],
  "idn"                => %w[libidn pkg-config],
  "libidn"             => %w[libidn pkg-config],
  "gpgme"              => %w[gpgme libgpg-error libassuan pkg-config],
  "libcurl"            => %w[curl pkg-config],
  "curl"               => %w[curl pkg-config],
  "ncurses"            => %w[ncurses],
  "ncursesw"           => %w[ncurses],
  "hiredis"            => %w[hiredis pkg-config],
  "yajl"               => %w[yajl pkg-config],
  "libsodium"          => %w[libsodium pkg-config],
  "vips"               => %w[vips pkg-config],
  "libvips"            => %w[vips pkg-config],
  "protobuf"           => %w[protobuf pkg-config],
  "pcre"               => %w[pcre pkg-config],
  "pcre2"              => %w[pcre2 pkg-config],
}.freeze

# Strings to ignore in have_library — these are always available or not real deps
LIB_IGNORE = Set.new(%w[c m dl pthread rt nsl socket stdc++ gcc_s objc]).freeze

# Build-time gem requires that map to a gem name
BUILD_TIME_GEMS = {
  "mini_portile2" => "mini_portile2",
  "rb_sys/mkmf"   => "rb_sys",
  "rb_sys"         => "rb_sys",
  "pkg-config"     => "pkg-config",
  "mkmf-rice"      => "rice",
  "rice"           => "rice",
}.freeze

# Scan an extconf.rb file and return auto-detected info:
#   { deps: Set<String>, extconf_flags: String|nil, build_gem_deps: Array<String>, is_rust: bool }
def scan_extconf(source_dir)
  result = { deps: Set.new, extconf_flags: nil, build_gem_deps: [], is_rust: false }

  extconfs = Dir.glob(File.join(source_dir, "ext", "**", "extconf.rb"))
  return result if extconfs.empty?

  # Check for Rust extension (Cargo.toml with rb-sys)
  cargo_tomls = Dir.glob(File.join(source_dir, "ext", "**", "Cargo.toml"))
  cargo_tomls.each do |ct|
    content = File.read(ct) rescue next
    if content.include?("rb-sys") || content.include?("rb_sys")
      result[:is_rust] = true
      result[:build_gem_deps] << "rb_sys"
      break
    end
  end

  extconfs.each do |extconf|
    content = File.read(extconf) rescue next

    # Category 1: pkg_config / find_header / have_library
    content.scan(/pkg_config\s*\(\s*['"]([^'"]+)['"]\s*\)/) do |m|
      lib = m[0]
      if LIB_TO_NIXPKGS.key?(lib)
        LIB_TO_NIXPKGS[lib].each { |dep| result[:deps] << dep }
      end
    end

    content.scan(/find_header\s*\(\s*['"]([^'"]+)['"]\s*/) do |m|
      header = m[0]
      # Map common headers to libraries
      LIB_TO_NIXPKGS.each do |lib, deps|
        if header.downcase.include?(lib.downcase.sub(/^lib/, ""))
          deps.each { |dep| result[:deps] << dep }
        end
      end
    end

    content.scan(/have_library\s*\(\s*['"]([^'"]+)['"]/) do |m|
      lib = m[0]
      next if LIB_IGNORE.include?(lib)
      if LIB_TO_NIXPKGS.key?(lib)
        LIB_TO_NIXPKGS[lib].each { |dep| result[:deps] << dep }
      end
    end

    # Category 2: system libraries flag
    if content.include?('enable_config("system-libraries")') ||
       content.include?("enable_config('system-libraries')")
      result[:extconf_flags] = "--enable-system-libraries"
    end

    if content.include?("--use-system-libraries")
      result[:extconf_flags] ||= "--use-system-libraries"
    end

    # Category 4: build-time gem deps
    content.scan(/require\s+['"]([^'"]+)['"]/) do |m|
      req = m[0]
      if BUILD_TIME_GEMS.key?(req)
        result[:build_gem_deps] << BUILD_TIME_GEMS[req]
      end
    end
  end

  result[:build_gem_deps].uniq!
  result
end

i = 0
while i < ARGV.length
  case ARGV[i]
  when "-o", "--output" then output_dir = ARGV[i += 1]
  when "-h", "--help"
    $stderr.puts "Usage: generate [-o nix/gem/]"
    exit 0
  else abort "Unknown option: #{ARGV[i]}"
  end
  i += 1
end

output_dir = File.expand_path(output_dir)
FileUtils.mkdir_p(output_dir)

# Which gems have overlays?
overlays = {}
if Dir.exist?(OVERLAYS_DIR)
  Dir.glob(File.join(OVERLAYS_DIR, "*.nix")).each do |f|
    overlays[File.basename(f, ".nix")] = true
  end
end

# -- Load all metadata -----------------------------------------------------

meta_by_key = {}
Dir.glob(File.join(META_DIR, "*.json")).each do |f|
  m = JSON.parse(File.read(f), symbolize_names: true)
  meta_by_key["#{m[:name]}-#{m[:version]}"] = m
end

$stderr.puts "#{meta_by_key.size} gems in cache (#{overlays.size} overlays)"

# -- Helper: indented heredoc content for nixfmt ---------------------------
#
# nixfmt wants shell lines at 4 spaces, heredoc body at 0 spaces, and
# heredoc terminator at 0 spaces (relative to Nix ''..'' baseline).
# Since nix strips the minimum indent, we emit:
#   - shell lines at 8 spaces (becomes 4 in bash)
#   - heredoc body at 4 spaces (becomes 0 in bash)
#   - heredoc terminator at 4 spaces (becomes 0 in bash)
#
SH  = "        "  # 8 spaces — shell commands
HD  = "    "      # 4 spaces — heredoc body / terminator
CL  = "  "        # 2 spaces — '' closer

# -- Per-gem derivations ---------------------------------------------------

generated = 0

meta_by_key.each_value do |meta|
  name    = meta[:name]
  version = meta[:version]
  key     = "#{name}-#{version}"

  source_dir = File.join(SOURCE_DIR, key)
  next unless Dir.exist?(source_dir)

  has_ext       = meta[:has_extensions] || !Dir.glob(File.join(source_dir, "ext", "**", "extconf.rb")).empty?
  require_paths = meta[:require_paths] || ["lib"]
  executables   = meta[:executables] || []
  bindir        = meta[:bindir] || "exe"

  # Verify require_paths exist
  verified = require_paths.select { |p| Dir.exist?(File.join(source_dir, p)) }
  require_paths = verified unless verified.empty?

  gem_dir = File.join(output_dir, name, version)
  FileUtils.mkdir_p(gem_dir)
  FileUtils.ln_sf(source_dir, File.join(gem_dir, "source"))

  has_overlay = overlays.key?(name)
  has_heredoc = true  # installPhase always has gemspec heredoc

  # Auto-detect deps from extconf.rb (only used when no manual overlay exists)
  auto = has_ext && !has_overlay ? scan_extconf(source_dir) : nil
  auto_has_deps = auto && (!auto[:deps].empty? || !auto[:build_gem_deps].empty? || auto[:is_rust])
  # Need pkgs when overlay exists OR when auto-detection found system deps
  needs_pkgs = has_overlay || (auto_has_deps && !auto[:deps].empty?)

  # Pick indent: 4 spaces if no heredoc in block, 8 if heredoc present
  si = has_heredoc ? SH : "    "

  nix = +""
  nix << "#\n"
  nix << "# ╔══════════════════════════════════════════════════════════════╗\n"
  nix << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
  nix << "# ╚══════════════════════════════════════════════════════════════╝\n"
  nix << "#\n"
  nix << "# #{name} #{version}\n"
  if auto_has_deps
    nix << "# auto-detected: deps=[#{auto[:deps].to_a.join(", ")}]"
    nix << " extconfFlags=#{auto[:extconf_flags]}" if auto[:extconf_flags]
    nix << " rust" if auto[:is_rust]
    nix << " build-gems=[#{auto[:build_gem_deps].join(", ")}]" unless auto[:build_gem_deps].empty?
    nix << "\n"
  end
  nix << "#\n"

  args = ["lib", "stdenv", "ruby"]
  args << "pkgs" if needs_pkgs
  nix << "{\n"
  args.each { |a| nix << "  #{a},\n" }
  nix << "}:\n"

  nix << "let\n"
  nix << "  rubyVersion = \"${ruby.version.majMin}.0\";\n"
  nix << "  arch = stdenv.hostPlatform.system;\n"
  nix << "  bundle_path = \"ruby/${rubyVersion}\";\n"

  if has_overlay
    nix << "  overlay = import ../../../../overlays/#{name}.nix { inherit pkgs ruby; };\n"
    nix << "  overlayDeps = if builtins.isList overlay then overlay else overlay.deps or [ ];\n"
    nix << "  overlayBuildPhase =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? buildPhase then overlay.buildPhase else null;\n"
    nix << "  overlayBeforeBuild =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? beforeBuild then overlay.beforeBuild else \"\";\n"
    nix << "  overlayAfterBuild =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? afterBuild then overlay.afterBuild else \"\";\n"
    nix << "  overlayPostInstall =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? postInstall then overlay.postInstall else \"\";\n"
    nix << "  overlayExtconfFlags =\n"
    nix << "    if builtins.isAttrs overlay && overlay ? extconfFlags then overlay.extconfFlags else \"\";\n"
  end

  # Auto-detected build-time gem deps: resolve to derivation paths
  if auto && !auto[:build_gem_deps].empty? && !auto[:is_rust]
    auto[:build_gem_deps].each do |gdep|
      # Find the latest version of this gem in our pool
      gdep_dir = File.join(output_dir, gdep)
      if Dir.exist?(gdep_dir)
        versions = Dir.children(gdep_dir)
                      .select { |d| d != "default.nix" && File.directory?(File.join(gdep_dir, d)) && !d.start_with?("git-") }
                      .sort_by { |v| Gem::Version.new(v) rescue Gem::Version.new("0") }
        unless versions.empty?
          v = versions.last
          nix << "  #{gdep.gsub("-", "_")} = import ../../../#{gdep}/#{v} { inherit lib stdenv ruby; };\n"
        end
      end
    end
  end

  # Rust gems: emit rb_sys derivation
  if auto&.dig(:is_rust)
    rb_sys_dir = File.join(output_dir, "rb_sys")
    if Dir.exist?(rb_sys_dir)
      rb_sys_versions = Dir.children(rb_sys_dir)
                           .select { |d| d != "default.nix" && File.directory?(File.join(rb_sys_dir, d)) && !d.start_with?("git-") }
                           .sort_by { |v| Gem::Version.new(v) rescue Gem::Version.new("0") }
      unless rb_sys_versions.empty?
        nix << "  rb_sys = import ../../../rb_sys/#{rb_sys_versions.last} { inherit lib stdenv ruby; };\n"
      end
    end
  end

  nix << "in\n"
  nix << "stdenv.mkDerivation {\n"
  nix << "  pname = \"#{name}\";\n"
  nix << "  version = \"#{version}\";\n"
  nix << "  src = builtins.path {\n"
  nix << "    path = ./source;\n"
  nix << "    name = \"#{key}-source\";\n"
  nix << "  };\n\n"

  if has_ext
    # Default build: find all extconf.rb, build each, copy .so to lib/
    default_build_lines = [
      "for extconf in $(find ext -name extconf.rb 2>/dev/null); do",
      "  dir=$(dirname \"$extconf\")",
      "  echo \"Building extension in $dir\"",
      "  (cd \"$dir\" && ruby extconf.rb $extconfFlags && make -j$NIX_BUILD_CORES)",
      "done",
      "for makefile in $(find ext -name Makefile 2>/dev/null); do",
      "  dir=$(dirname \"$makefile\")",
      "  target_name=$(sed -n 's/^TARGET = //p' \"$makefile\")",
      "  target_prefix=$(sed -n 's/^target_prefix = //p' \"$makefile\")",
      "  if [ -n \"$target_name\" ] && [ -f \"$dir/$target_name.so\" ]; then",
      "    mkdir -p \"lib$target_prefix\"",
      "    cp \"$dir/$target_name.so\" \"lib$target_prefix/$target_name.so\"",
      "    echo \"Installed $dir/$target_name.so -> lib$target_prefix/$target_name.so\"",
      "  fi",
      "done",
    ]
    if has_overlay
      nix << "  nativeBuildInputs = [ ruby ] ++ overlayDeps;\n\n"
      nix << "  buildPhase =\n"
      nix << "    if overlayBuildPhase != null then\n"
      nix << "      overlayBuildPhase\n"
      nix << "    else\n"
      nix << "      ''\n"
      nix << "        extconfFlags=\"${overlayExtconfFlags}\"\n"
      nix << "        ${overlayBeforeBuild}\n"
      default_build_lines.each { |l| nix << "        #{l}\n" }
      nix << "        ${overlayAfterBuild}\n"
      nix << "      '';\n\n"
    elsif auto&.dig(:is_rust)
      # Rust extension via rb_sys — full Rust build environment
      rust_deps = %w[pkgs.rustPlatform.rust.cargo pkgs.rustPlatform.rust.rustc pkgs.llvmPackages.libclang]
      auto[:deps].each { |d| rust_deps << "pkgs.#{d}" }
      nix << "  nativeBuildInputs = [ ruby #{rust_deps.join(" ")} ];\n\n"
      nix << "  buildPhase = ''\n"
      nix << "    export GEM_PATH=${rb_sys}/${rb_sys.bundle_path}\n"
      nix << "    export CARGO_HOME=\"$TMPDIR/cargo\"\n"
      nix << "    mkdir -p \"$CARGO_HOME\"\n"
      nix << "    export LIBCLANG_PATH=\"${pkgs.llvmPackages.libclang.lib}/lib\"\n"
      nix << "    export BINDGEN_EXTRA_CLANG_ARGS=\"-isystem ${pkgs.stdenv.cc.cc}/lib/gcc/${pkgs.stdenv.hostPlatform.config}/${pkgs.stdenv.cc.cc.version}/include\"\n"
      nix << "    export CC=\"${pkgs.stdenv.cc}/bin/cc\"\n"
      nix << "    export CXX=\"${pkgs.stdenv.cc}/bin/c++\"\n"
      nix << "    extconfFlags=\"#{auto[:extconf_flags] || ""}\"\n"
      default_build_lines.each { |l| nix << "    #{l}\n" }
      nix << "  '';\n\n"
    elsif auto_has_deps
      # Auto-detected system deps — inline them
      dep_list = auto[:deps].map { |d| "pkgs.#{d}" }.join(" ")
      nix << "  nativeBuildInputs = [ ruby #{dep_list} ];\n\n"
      nix << "  buildPhase = ''\n"
      nix << "    extconfFlags=\"#{auto[:extconf_flags] || ""}\"\n"
      # Build-time gem deps → GEM_PATH
      unless auto[:build_gem_deps].empty? || auto[:is_rust]
        gem_paths = auto[:build_gem_deps].map { |g| "${#{g.gsub("-", "_")}}/${#{g.gsub("-", "_")}.bundle_path}" }
        nix << "    export GEM_PATH=#{gem_paths.join(":")}\n"
      end
      default_build_lines.each { |l| nix << "    #{l}\n" }
      nix << "  '';\n\n"
    else
      nix << "  nativeBuildInputs = [ ruby ];\n\n"
      nix << "  buildPhase = ''\n"
      nix << "    extconfFlags=\"\"\n"
      default_build_lines.each { |l| nix << "    #{l}\n" }
      nix << "  '';\n\n"
    end
  else
    nix << "  dontBuild = true;\n"
  end

  nix << "  dontConfigure = true;\n\n"
  nix << "  passthru = { inherit bundle_path; };\n\n"

  nix << "  installPhase = ''\n"
  nix << "#{si}local dest=$out/${bundle_path}\n"
  nix << "#{si}mkdir -p $dest/gems/#{key}\n"
  nix << "#{si}cp -r . $dest/gems/#{key}/\n"

  if has_ext
    nix << "#{si}local extdir=$dest/extensions/${arch}/${rubyVersion}/#{key}\n"
    nix << "#{si}mkdir -p $extdir\n"
    nix << "#{si}find . -name '*.so' -path '*/lib/*' | while read so; do\n"
    nix << "#{si}  cp \"$so\" \"$extdir/\"\n"
    nix << "#{si}done\n"
    nix << "#{si}local gp=\"${stdenv.hostPlatform.parsed.cpu.name}-${stdenv.hostPlatform.parsed.kernel.name}\"\n"
    nix << "#{si}if [ \"${stdenv.hostPlatform.parsed.abi.name}\" != \"unknown\" ]; then\n"
    nix << "#{si}  gp=\"$gp-${stdenv.hostPlatform.parsed.abi.name}\"\n"
    nix << "#{si}fi\n"
    nix << "#{si}ln -s #{key} $dest/gems/#{key}-$gp\n"
    nix << "#{si}ln -s #{key} $dest/extensions/${arch}/${rubyVersion}/#{key}-$gp\n"
  end

  nix << "#{si}mkdir -p $dest/specifications\n"
  nix << "#{si}cat > $dest/specifications/#{key}.gemspec <<'EOF'\n"
  nix << "#{HD}Gem::Specification.new do |s|\n"
  nix << "#{HD}  s.name = \"#{name}\"\n"
  nix << "#{HD}  s.version = \"#{version}\"\n"
  nix << "#{HD}  s.summary = \"#{name}\"\n"
  nix << "#{HD}  s.require_paths = [#{require_paths.map { |p| "\"#{p}\"" }.join(", ")}]\n"
  unless executables.empty?
    nix << "#{HD}  s.bindir = \"#{bindir}\"\n"
    nix << "#{HD}  s.executables = [#{executables.map { |e| "\"#{e}\"" }.join(", ")}]\n"
  end
  nix << "#{HD}  s.files = []\n"
  nix << "#{HD}end\n"
  nix << "#{HD}EOF\n"

  if has_ext
    rp_str = require_paths.map { |p| "\"#{p}\"" }.join(", ")
    nix << "#{si}cat > $dest/specifications/#{key}-$gp.gemspec <<PLATSPEC\n"
    nix << "#{HD}Gem::Specification.new do |s|\n"
    nix << "#{HD}  s.name = \"#{name}\"\n"
    nix << "#{HD}  s.version = \"#{version}\"\n"
    nix << "#{HD}  s.platform = \"$gp\"\n"
    nix << "#{HD}  s.summary = \"#{name}\"\n"
    nix << "#{HD}  s.require_paths = [#{rp_str}]\n"
    unless executables.empty?
      nix << "#{HD}  s.bindir = \"#{bindir}\"\n"
      nix << "#{HD}  s.executables = [#{executables.map { |e| "\"#{e}\"" }.join(", ")}]\n"
    end
    nix << "#{HD}  s.files = []\n"
    nix << "#{HD}end\n"
    nix << "#{HD}PLATSPEC\n"
  end

  unless executables.empty?
    nix << "#{si}mkdir -p $dest/bin\n"
    executables.each do |exe|
      nix << "#{si}cat > $dest/bin/#{exe} <<'BINSTUB'\n"
      nix << "#{HD}#!/usr/bin/env ruby\n"
      nix << "#{HD}require \"rubygems\"\n"
      nix << "#{HD}load Gem.bin_path(\"#{name}\", \"#{exe}\", \"#{version}\")\n"
      nix << "#{HD}BINSTUB\n"
      nix << "#{si}chmod +x $dest/bin/#{exe}\n"
    end
  end

  if has_overlay
    nix << "#{si}${overlayPostInstall}\n"
  end
  nix << "  '';\n"
  nix << "}\n"

  File.write(File.join(gem_dir, "default.nix"), nix)
  generated += 1
end

$stderr.puts "#{generated} derivations"

# -- Per-gem selector: nix/gem/<name>/default.nix -------------------------
#
# Groups all versions (and later git refs, added by import) into a
# selector that supports:
#
#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };
#   gems.rails { version = "7.1.5.2"; }
#   gems.rails { git.rev = "60d92e4e7dfe"; }

# Track which gems need pkgs (overlay or auto-detected system deps)
gems_needing_pkgs = Set.new
overlays.each_key { |n| gems_needing_pkgs << n }

gems_by_name = {}
meta_by_key.each_value do |meta|
  name = meta[:name]
  version = meta[:version]
  source_dir = File.join(SOURCE_DIR, "#{name}-#{version}")
  next unless Dir.exist?(source_dir)
  info = (gems_by_name[name] ||= { versions: [], needs_pkgs: overlays.key?(name) })
  info[:versions] << version
  # Check if any version of this gem has auto-detected system deps
  unless info[:needs_pkgs]
    has_ext = meta[:has_extensions] || !Dir.glob(File.join(source_dir, "ext", "**", "extconf.rb")).empty?
    if has_ext
      auto = scan_extconf(source_dir)
      if !auto[:deps].empty? || auto[:is_rust]
        info[:needs_pkgs] = true
        gems_needing_pkgs << name
      end
    end
  end
end

gems_by_name.each do |name, info|
  versions = info[:versions].sort_by { |v| Gem::Version.new(v) }
  needs_pkgs = info[:needs_pkgs]
  latest = versions.last

  sel = +""
  sel << "#\n"
  sel << "# ╔══════════════════════════════════════════════════════════════╗\n"
  sel << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
  sel << "# ╚══════════════════════════════════════════════════════════════╝\n"
  sel << "#\n"
  sel << "# #{name}\n"
  sel << "#\n"
  sel << "# Available versions:\n"
  versions.each { |v| sel << "#   #{v}\n" }
  sel << "#\n"
  sel << "# Usage:\n"
  sel << "#   #{name} { version = \"#{latest}\"; }\n"
  sel << "#   #{name} { }  # latest (#{latest})\n"
  sel << "#\n"
  sel << "{\n"
  sel << "  lib,\n"
  sel << "  stdenv,\n"
  sel << "  ruby,\n"
  sel << "  pkgs ? null,\n"
  sel << "  version ? \"#{latest}\",\n"
  sel << "  git ? { },\n"
  sel << "}:\n"
  sel << "let\n"

  sel << "  versions = {\n"
  versions.each do |v|
    if needs_pkgs
      sel << "    \"#{v}\" = import ./#{v} {\n"
      sel << "      inherit\n"
      sel << "        lib\n"
      sel << "        stdenv\n"
      sel << "        ruby\n"
      sel << "        pkgs\n"
      sel << "        ;\n"
      sel << "    };\n"
    else
      sel << "    \"#{v}\" = import ./#{v} { inherit lib stdenv ruby; };\n"
    end
  end
  sel << "  };\n\n"

  sel << "  gitRevs = {\n"
  # Populated by import
  sel << "  };\n"

  sel << "in\n"
  sel << "if git ? rev then\n"
  sel << "  gitRevs.\${git.rev}\n"
  sel << "    or (throw \"#{name}: unknown git rev '\${git.rev}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\")\n"
  sel << "else\n"
  sel << "  versions.\${version}\n"
  sel << "    or (throw \"#{name}: unknown version '\${version}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames versions)}\")\n"

  File.write(File.join(output_dir, name, "default.nix"), sel)
end

$stderr.puts "#{gems_by_name.size} selectors"

# -- Top-level nix/gem/default.nix ---------------------------------------
#
# Exposes every gem as a callable selector:
#
#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };
#   gems.rails { version = "7.1.5.2"; }
#   gems.rails { git.rev = "60d92e4e7dfe"; }
#   gems.sqlite3 { version = "2.8.0"; }
#

top = +""
top << "#\n"
top << "# ╔══════════════════════════════════════════════════════════════╗\n"
top << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
top << "# ╚══════════════════════════════════════════════════════════════╝\n"
top << "#\n"
top << "# #{gems_by_name.size} gems\n"
top << "#\n"
top << "# Usage:\n"
top << "#   gems = import ./nix/modules/gem.nix { inherit pkgs ruby; };\n"
top << "#   gems.rails { version = \"7.1.5.2\"; }\n"
top << "#   gems.rails { git.rev = \"60d92e4e7dfe\"; }\n"
top << "#   gems.rack {}  # latest\n"
top << "#\n"
top << "{ pkgs, ruby }:\n\n"
top << "let\n"
top << "  inherit (pkgs) lib stdenv;\n"
top << "  gem =\n"
top << "    name: args:\n"
top << "    import (../gem + \"/\${name}\") (\n"
top << "      {\n"
top << "        inherit\n"
top << "          lib\n"
top << "          stdenv\n"
top << "          ruby\n"
top << "          pkgs\n"
top << "          ;\n"
top << "      }\n"
top << "      // args\n"
top << "    );\n"
top << "in\n"
top << "{\n"

gems_by_name.keys.sort.each do |name|
  top << "  #{name.inspect} = args: gem #{name.inspect} args;\n"
end

top << "}\n"

modules_dir = File.join(output_dir, "..", "modules")
FileUtils.mkdir_p(modules_dir)
File.write(File.join(modules_dir, "gem.nix"), top)
$stderr.puts "-> nix/modules/gem.nix"
