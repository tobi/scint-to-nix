#!/usr/bin/env ruby
# frozen_string_literal: true

# fetch-gem — fetch a single gem into cache/
#
# Reads one line from stdin or argv: "name version [git:uri@rev]"
# Fetches the .gem, unpacks source, extracts metadata.
# For git gems, clones the repo instead.
#
# Usage:
#   echo "rack 3.2.4" | fetch-gem
#   fetch-gem "nokogiri 1.19.0"
#   fetch-gem "rails 8.2.0.alpha git:https://github.com/rails/rails.git@60d92e4..."

require "fileutils"
require "json"
require "open3"
require "yaml"
require "rubygems/package"
require "stringio"
require "zlib"

ROOT      = File.expand_path(File.join(__dir__, ".."))
CACHE_DIR = File.join(ROOT, "cache")
GEM_DIR   = File.join(CACHE_DIR, "gems")
SOURCE_DIR = File.join(CACHE_DIR, "sources")
META_DIR  = File.join(CACHE_DIR, "meta")

[GEM_DIR, SOURCE_DIR, META_DIR].each { |d| FileUtils.mkdir_p(d) }

def fetch_rubygem(name, version)
  gem_file = File.join(GEM_DIR, "#{name}-#{version}.gem")
  return gem_file if File.exist?(gem_file)

  _out, _err, status = Open3.capture3(
    "gem", "fetch", name, "-v", version, "--platform", "ruby",
    chdir: GEM_DIR
  )

  unless status.success?
    _out, _err, status = Open3.capture3(
      "gem", "fetch", name, "-v", version,
      chdir: GEM_DIR
    )
  end

  return nil unless status.success?

  Dir.glob(File.join(GEM_DIR, "#{name}-#{version}*.gem")).sort.first
end

def unpack_gem(gem_file, name, version)
  target = File.join(SOURCE_DIR, "#{name}-#{version}")
  return target if Dir.exist?(target)

  _out, err, status = Open3.capture3(
    "gem", "unpack", gem_file, "--target", SOURCE_DIR
  )

  unless status.success?
    $stderr.puts "ERROR: unpack #{name}-#{version}: #{err.strip}"
    return nil
  end

  unpacked = Dir.glob(File.join(SOURCE_DIR, "#{name}-#{version}*")).first
  FileUtils.mv(unpacked, target) if unpacked && unpacked != target

  # Strip prebuilt .so/.bundle/.dylib — we compile from source in Nix
  Dir.glob(File.join(target, "lib", "**", "*.{so,bundle,dylib}")).each { |f| File.delete(f) }

  target
end

def extract_metadata(gem_file, name, version)
  meta_file = File.join(META_DIR, "#{name}-#{version}.json")
  return if File.exist?(meta_file)

  meta = nil
  begin
    File.open(gem_file, "rb") do |io|
      Gem::Package::TarReader.new(io) do |tar|
        tar.each do |entry|
          if entry.full_name == "metadata.gz"
            yaml = Zlib::GzipReader.new(StringIO.new(entry.read)).read
            meta = YAML.safe_load(yaml,
              permitted_classes: [Gem::Specification, Gem::Version, Gem::Requirement,
                                 Gem::Dependency, Symbol, Time],
              aliases: true)
            break
          end
        end
      end
    end
  rescue => e
    $stderr.puts "WARN: metadata #{name}-#{version}: #{e.message}"
  end

  return unless meta

  source_dir = File.join(SOURCE_DIR, "#{name}-#{version}")
  has_extensions = if meta.respond_to?(:extensions) && !meta.extensions.empty?
    true
  elsif Dir.exist?(source_dir)
    !Dir.glob(File.join(source_dir, "ext", "**", "extconf.rb")).empty?
  else
    false
  end

  result = {
    "name" => name,
    "version" => version,
    "require_paths" => meta.require_paths || ["lib"],
    "executables" => meta.executables || [],
    "bindir" => meta.bindir || "exe",
    "has_extensions" => has_extensions,
    "dependencies" => (meta.dependencies || [])
      .select { |d| d.type == :runtime }
      .map { |d| { "name" => d.name, "requirement" => d.requirement.to_s } },
  }

  File.write(meta_file, JSON.pretty_generate(result))
end

def clone_git_gem(name, version, git_ref)
  target = File.join(SOURCE_DIR, "#{name}-#{version}")
  return if Dir.exist?(target)

  uri, rev = git_ref.split("@", 2)
  clone_dir = File.join(CACHE_DIR, "git-clones", File.basename(uri, ".git"))

  unless Dir.exist?(clone_dir)
    FileUtils.mkdir_p(File.dirname(clone_dir))
    system("git", "clone", "--quiet", uri, clone_dir)
  end

  system("git", "-C", clone_dir, "fetch", "--quiet", "origin", err: "/dev/null")
  system("git", "-C", clone_dir, "checkout", "--quiet", "--force", rev)

  FileUtils.cp_r(clone_dir, target)
  FileUtils.rm_rf(File.join(target, ".git"))
end

# -- Main ------------------------------------------------------------------

line = ARGV[0] || $stdin.gets
abort "Usage: fetch-gem 'name version [git:uri@rev]'" unless line

line = line.strip
exit 0 if line.empty? || line.start_with?("#")

parts = line.split
name = parts[0]
version = parts[1]
git = parts[2]&.start_with?("git:") ? parts[2].sub("git:", "") : nil

if git
  clone_git_gem(name, version, git)
  puts "git #{name}-#{version}"
else
  gem_file = fetch_rubygem(name, version)
  unless gem_file
    $stderr.puts "FAIL: #{name}-#{version}"
    exit 1
  end
  unpack_gem(gem_file, name, version)
  extract_metadata(gem_file, name, version)
  puts "#{name}-#{version}"
end
