#!/usr/bin/env ruby
# frozen_string_literal: true

# lockfile-to-gems — convert Gemfile.lock to a .gems manifest
#
# Usage:
#   lockfile-to-gems path/to/Gemfile.lock > project.gems
#   lockfile-to-gems path/to/Gemfile.lock -o gems/project.gems

require "fileutils"
require "bundler"

lockfile_path = nil
output_path   = nil

i = 0
while i < ARGV.length
  case ARGV[i]
  when "-o", "--output" then output_path = ARGV[i += 1]
  when "-h", "--help"
    $stderr.puts "Usage: lockfile-to-gems <Gemfile.lock> [-o output.gems]"
    exit 0
  else
    lockfile_path = ARGV[i]
  end
  i += 1
end

abort "Usage: lockfile-to-gems <Gemfile.lock> [-o output.gems]" unless lockfile_path

# Point Bundler at the project so git source parsing works
gemfile = lockfile_path.sub(/Gemfile\.lock$/, "Gemfile")
ENV["BUNDLE_GEMFILE"] = gemfile if File.exist?(gemfile)

lf = Bundler::LockfileParser.new(File.read(lockfile_path))

# Dedupe by name — prefer platform-specific over ruby (we just need the version)
by_name = {}
lf.specs.each do |spec|
  source = spec.source
  # Skip PATH sources (project's own code) unless they're git
  next if source.is_a?(Bundler::Source::Path) && !source.is_a?(Bundler::Source::Git)

  prev = by_name[spec.name]
  if prev.nil? || (spec.platform.to_s != "ruby" && prev.platform.to_s == "ruby")
    by_name[spec.name] = spec
  end
end

lines = by_name.values.sort_by(&:name).map do |spec|
  source = spec.source
  if source.is_a?(Bundler::Source::Git)
    "#{spec.name} #{spec.version} git:#{source.uri}@#{source.revision}"
  else
    "#{spec.name} #{spec.version}"
  end
end

output = lines.join("\n") + "\n"

if output_path
  FileUtils.mkdir_p(File.dirname(output_path))
  File.write(output_path, output)
  $stderr.puts "#{by_name.size} gems -> #{output_path}"
else
  $stdout.write(output)
end
