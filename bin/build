#!/usr/bin/env bash
set -euo pipefail

# build — build gem derivations
#
# Usage:
#   bin/build                   # build every gem version in the pool
#   bin/build fizzy             # build all gems for an app
#   bin/build fizzy rack        # build a single gem (debugging)

dir="$(cd "$(dirname "$0")" && pwd)"
root="$(cd "$dir/.." && pwd)"

app="${1:-}"
gem="${2:-}"
ruby="${RUBY:-ruby_3_4}"

buildlog=$(mktemp /tmp/gem-build-XXXXXX.log)
trap 'rm -f "$buildlog"' EXIT

collect_failure_logs() {
    local log="$1"
    if ! grep -q 'nix log' "$log" 2>/dev/null; then
        return
    fi

    echo ""
    echo "" >> "$log"
    echo "=== FAILURE LOGS ===" >> "$log"

    # Collect drv paths and extract gem name + version from each
    local drvs=()
    while IFS= read -r drv; do
        drvs+=("$drv")
        echo "" >> "$log"
        echo "--- nix log $drv ---" >> "$log"
        nix log "$drv" >> "$log" 2>&1 || true
    done < <(grep -oP '/nix/store/\S+\.drv' "$log" | sort -u)

    trap - EXIT  # keep the log file

    echo ""
    echo "Failed gems:"
    echo ""
    for drv in "${drvs[@]}"; do
        # Extract gem name + version from drv path: /nix/store/<hash>-<name>-<version>.drv
        local basename
        basename=$(echo "$drv" | sed 's|.*/[a-z0-9]*-||; s|\.drv$||')
        # Split into name and version: last segment starting with a digit is the version
        local gem_name gem_version overlay_path
        gem_name=$(echo "$basename" | sed 's/-[0-9][0-9.]*$//')
        gem_version=$(echo "$basename" | grep -oP '[0-9][0-9.]*$' || echo "unknown")
        overlay_path="overlays/${gem_name}.nix"

        if [[ -f "$root/$overlay_path" ]]; then
            echo "  ✗ ${gem_name} ${gem_version}  →  edit ${overlay_path}"
        else
            echo "  ✗ ${gem_name} ${gem_version}  →  create ${overlay_path}"
        fi
    done

    echo ""
    echo "Build log: $log"
    echo "Use /nix-build skill to fix — read $log for error details"
}

if [[ -n "$gem" && -n "$app" ]]; then
    # Single gem
    echo "Building $gem from $app..."
    exec nix-build --no-out-link -E \
        "let pkgs = import <nixpkgs> {};
             ruby = pkgs.${ruby};
             resolve = import ${root}/nix/modules/resolve.nix;
             gems = resolve { inherit pkgs ruby; gemset = import ${root}/nix/app/${app}.nix; };
         in gems.\"${gem}\""

elif [[ -n "$app" ]]; then
    # All gems for an app
    echo "Building all gems for ${app}..."
    paths=$(nix-build --no-out-link --keep-going -E \
        "let pkgs = import <nixpkgs> {};
             ruby = pkgs.${ruby};
             resolve = import ${root}/nix/modules/resolve.nix;
             gems = resolve { inherit pkgs ruby; gemset = import ${root}/nix/app/${app}.nix; };
         in builtins.attrValues gems" \
        2> >(tee -a "$buildlog" >&2)) || true
    n=$(echo "$paths" | grep -c '/nix/store/' || echo 0)
    echo "${n} gems built for ${app}."
    collect_failure_logs "$buildlog"

else
    # Every gem in the pool — use a nix file to avoid quoting hell
    total=$(find "$root/nix/gem" -mindepth 2 -maxdepth 2 -type d | wc -l)
    echo "Building ${total} gem derivations..."

    nixexpr=$(mktemp /tmp/gem-build-all-XXXXXX.nix)
    cat > "$nixexpr" <<EOF
let
  pkgs = import <nixpkgs> {};
  ruby = pkgs.${ruby};
  lib = pkgs.lib;
  root = ${root}/nix/gem;
  dirs = builtins.attrNames (builtins.readDir root);
  versionsOf = name:
    let
      entries = builtins.readDir (root + "/\${name}");
      subdirs = lib.filterAttrs (k: v: v == "directory") entries;
    in
    map (v: pkgs.callPackage (root + "/\${name}/\${v}") { inherit ruby; })
      (builtins.attrNames subdirs);
in
lib.concatMap versionsOf dirs
EOF

    paths=$(nix-build --no-out-link --keep-going "$nixexpr" \
        2> >(tee -a "$buildlog" >&2)) || true
    rm -f "$nixexpr"

    built=$(echo "$paths" | grep -c '/nix/store/' || true)
    failed=$((total - built))
    echo "${built}/${total} built, ${failed} failed."
    collect_failure_logs "$buildlog"
fi
