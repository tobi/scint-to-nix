#!/usr/bin/env ruby
# frozen_string_literal: true

# import — import a Ruby project into scint-to-nix
#
# Accepts a project name (looks for Gemfile.lock in well-known locations)
# or a path to a Gemfile or Gemfile.lock.
#
# Produces:
#   imports/<name>.gemset  — gem manifest (for bin/fetch)
#   nix/app/<name>.nix     — gemset (for nix-build / devshell)
#   nix/gem/<repo>/git-*/  — git repo derivations (if any)
#
# Usage:
#   import fizzy                                # looks for ~/src/ruby-tests/fizzy/Gemfile.lock
#   import ~/src/ruby-tests/fizzy/Gemfile.lock  # name = "fizzy" (parent dir)
#   import ~/src/ruby-tests/fizzy/Gemfile       # finds Gemfile.lock next to it
#   import --name myapp /some/path/Gemfile.lock  # explicit name

require "bundler"
require "digest"
require "fileutils"
require "pathname"
require "uri"

ROOT         = File.expand_path(File.join(__dir__, ".."))
OVERLAYS_DIR = File.join(ROOT, "overlays")
GEMS_DIR     = File.join(ROOT, "imports")
OUTPUT_DIR   = File.join(ROOT, "nix", "gem")
APP_DIR      = File.join(ROOT, "nix", "app")

# -- Argument parsing -------------------------------------------------------

name_override = nil
positional    = []

i = 0
while i < ARGV.length
  case ARGV[i]
  when "--name", "-n"
    name_override = ARGV[i += 1]
  when "--help", "-h"
    $stderr.puts <<~USAGE
      Usage:
        import <name>                      # look up Gemfile.lock by project name
        import <path/to/Gemfile.lock>      # name = parent dir basename
        import <path/to/Gemfile>           # finds Gemfile.lock next to it
        import --name <name> <path>        # explicit name override

      Produces imports/<name>.gemset + nix/app/<name>.nix
    USAGE
    exit 0
  else
    positional << ARGV[i]
  end
  i += 1
end

abort "Usage: import [--name NAME] <project-or-path>" if positional.empty?

# -- Resolve the lockfile and project name ----------------------------------

arg = positional[0]

if File.exist?(arg)
  path = File.expand_path(arg)
  if File.basename(path) == "Gemfile"
    lockfile = "#{path}.lock"
    abort "No Gemfile.lock found next to #{path}" unless File.exist?(lockfile)
  elsif File.basename(path) == "Gemfile.lock"
    lockfile = path
  elsif File.directory?(path)
    lockfile = File.join(path, "Gemfile.lock")
    abort "No Gemfile.lock in #{path}" unless File.exist?(lockfile)
  else
    abort "Don't know how to import #{path} — expected Gemfile, Gemfile.lock, or a directory"
  end
  project = name_override || File.basename(File.dirname(lockfile))
else
  # Treat as a project name — search well-known locations
  project = name_override || arg
  candidates = [
    File.join(ROOT, "..", arg, "Gemfile.lock"),
    File.expand_path("~/src/ruby-tests/#{arg}/Gemfile.lock"),
    File.expand_path("~/src/#{arg}/Gemfile.lock"),
  ]
  lockfile = candidates.find { |c| File.exist?(c) }
  abort "Cannot find Gemfile.lock for '#{arg}'. Searched:\n  #{candidates.join("\n  ")}" unless lockfile
end

$stderr.puts "Importing #{project} from #{lockfile}"

# -- Generate .gems manifest -----------------------------------------------

gemfile = lockfile.sub(/Gemfile\.lock$/, "Gemfile")
ENV["BUNDLE_GEMFILE"] = File.expand_path(gemfile) if File.exist?(gemfile)

lf = Bundler::LockfileParser.new(File.read(lockfile))

# Dedupe by name — prefer platform-specific over ruby
by_name = {}
lf.specs.each do |spec|
  source = spec.source
  next if source.is_a?(Bundler::Source::Path) && !source.is_a?(Bundler::Source::Git)

  prev = by_name[spec.name]
  if prev.nil? || (spec.platform.to_s != "ruby" && prev[:spec].platform.to_s == "ruby")
    by_name[spec.name] = { spec: spec, source: source }
  end
end

gems_lines = by_name.values.sort_by { |e| e[:spec].name }.map do |entry|
  spec = entry[:spec]
  source = entry[:source]
  if source.is_a?(Bundler::Source::Git)
    "#{spec.name} #{spec.version} git:#{source.uri}@#{source.revision}"
  else
    "#{spec.name} #{spec.version}"
  end
end

FileUtils.mkdir_p(GEMS_DIR)
gems_path = File.join(GEMS_DIR, "#{project}.gemset")
File.write(gems_path, gems_lines.join("\n") + "\n")
$stderr.puts "  -> imports/#{project}.gemset (#{by_name.size} gems)"

# -- Which gems have overlays? ----------------------------------------------

overlays = {}
if Dir.exist?(OVERLAYS_DIR)
  Dir.glob(File.join(OVERLAYS_DIR, "*.nix")).each do |f|
    overlays[File.basename(f, ".nix")] = true
  end
end

# -- Classify specs ---------------------------------------------------------

rubygem_specs = []
git_specs = []

lf.specs.each do |spec|
  src = spec.source
  case src
  when Bundler::Source::Git
    base = File.basename(src.uri, ".git")
    git_specs << { spec: spec, uri: src.uri, rev: src.revision,
                   base: base, shortrev: src.revision[0, 12] }
  when Bundler::Source::Path
    next
  else
    existing = rubygem_specs.find { |s| s.name == spec.name }
    if existing
      rubygem_specs.delete(existing) if spec.platform.to_s == "ruby"
      next unless spec.platform.to_s == "ruby"
    end
    rubygem_specs << spec
  end
end

# Group git specs by repo+rev
git_repos = {}
git_specs.each do |gs|
  key = "#{gs[:base]}-#{gs[:shortrev]}"
  unless git_repos[key]
    uri = gs[:uri]
    input = if %r{^\w+://(\w+@)?}.match?(uri)
              URI.parse(uri).normalize.to_s.sub(%r{/$}, "")
            else
              uri
            end
    uri_hash = Digest::SHA1.hexdigest(input)
    git_repos[key] = { uri: gs[:uri], rev: gs[:rev], base: gs[:base],
                        shortrev: gs[:shortrev], uri_hash: uri_hash, gems: [] }
  end
  git_repos[key][:gems] << gs[:spec] unless git_repos[key][:gems].any? { |e| e.name == gs[:spec].name }
end

$stderr.puts "  #{rubygem_specs.size} rubygems, #{git_specs.size} git (#{git_repos.size} repos)"

# -- Generate gemset .nix --------------------------------------------------

nix = +""
nix << "#\n"
nix << "# ╔═══════════════════════════════════════════════════════╗\n"
nix << "# ║  GENERATED — do not edit.  Run bin/import to refresh ║\n"
nix << "# ╚═══════════════════════════════════════════════════════╝\n"
nix << "#\n"
nix << "# #{project.upcase} — #{rubygem_specs.size + git_specs.size} gems\n"
nix << "# Generated from #{File.basename(lockfile)}\n"
nix << "#\n"
nix << "[\n"

rubygem_specs.sort_by(&:name).each do |spec|
  nix << "  { name = #{spec.name.inspect}; version = #{spec.version.to_s.inspect}; }\n"
end

git_repos.each do |_repo_key, repo|
  nix << "  # git: #{repo[:base]} @ #{repo[:shortrev]}\n"
  nix << "  { name = #{repo[:base].inspect}; git.rev = #{repo[:shortrev].inspect}; }\n"
end

nix << "]\n"

# -- Rebuild apps.nix registry after writing the app file -------------------
rebuild_apps_registry = -> {
  apps_dir = APP_DIR
  apps = +""
  apps << "#\n"
  apps << "# ╔═══════════════════════════════════════════════════════╗\n"
  apps << "# ║  GENERATED — do not edit.  Run bin/import to refresh ║\n"
  apps << "# ╚═══════════════════════════════════════════════════════╝\n"
  apps << "#\n"
  apps << "# App presets for gem.app.<name>.enable = true\n"
  apps << "#\n"
  apps << "{\n"
  Dir.glob(File.join(apps_dir, "*.nix")).sort.each do |f|
    name = File.basename(f, ".nix")
    apps << "  #{name.inspect} = import ../app/#{name}.nix;\n"
  end
  apps << "}\n"
  File.write(File.join(apps_dir, "..", "modules", "apps.nix"), apps)
}

FileUtils.mkdir_p(APP_DIR)
File.write(File.join(APP_DIR, "#{project}.nix"), nix)
$stderr.puts "  -> nix/app/#{project}.nix"
rebuild_apps_registry.call
$stderr.puts "  -> nix/modules/apps.nix"

# -- Generate git repo derivations -----------------------------------------

SH = "        "  # 8 spaces — shell commands (nixfmt heredoc style)
HD = "    "      # 4 spaces — heredoc body / terminator

git_repos.each do |repo_key, repo|
  source_dir = nil
  repo[:gems].each do |spec|
    candidate = File.join(ROOT, "cache", "sources", "#{spec.name}-#{spec.version}")
    if Dir.exist?(candidate)
      source_dir = File.expand_path(candidate)
      break
    end
  end

  unless source_dir
    $stderr.puts "  WARN: no source for git repo #{repo_key}"
    next
  end

  git_dir = File.join(OUTPUT_DIR, repo[:base], "git-#{repo[:shortrev]}")
  FileUtils.mkdir_p(git_dir)
  source_link = File.join(git_dir, "source")
  FileUtils.rm_f(source_link)
  FileUtils.ln_s(File.expand_path(source_dir), source_link)

  # Check which gems need a generated gemspec
  missing_gemspecs = repo[:gems].select do |spec|
    !File.exist?(File.join(source_dir, "#{spec.name}.gemspec")) &&
      !File.exist?(File.join(source_dir, spec.name, "#{spec.name}.gemspec"))
  end

  has_heredoc = !missing_gemspecs.empty?
  si = has_heredoc ? SH : "    "

  gnix = +""
  gnix << "#\n"
  gnix << "# ╔═══════════════════════════════════════════════════════╗\n"
  gnix << "# ║  GENERATED — do not edit.  Run bin/import to refresh ║\n"
  gnix << "# ╚═══════════════════════════════════════════════════════╝\n"
  gnix << "#\n"
  gnix << "# Git: #{repo[:base]} @ #{repo[:shortrev]}\n"
  gnix << "# URI: #{repo[:uri]}\n"
  gnix << "# Gems: #{repo[:gems].map(&:name).join(", ")}\n"
  gnix << "#\n"
  gnix << "{\n"
  gnix << "  lib,\n"
  gnix << "  stdenv,\n"
  gnix << "  ruby,\n"
  gnix << "}:\n"
  gnix << "let\n"
  gnix << "  rubyVersion = \"${ruby.version.majMin}.0\";\n"
  gnix << "  bundle_path = \"ruby/${rubyVersion}\";\n"
  gnix << "in\n"
  gnix << "stdenv.mkDerivation {\n"
  gnix << "  pname = #{repo[:base].inspect};\n"
  gnix << "  version = #{repo[:shortrev].inspect};\n"
  gnix << "  src = builtins.path {\n"
  gnix << "    path = ./source;\n"
  gnix << "    name = \"#{repo_key}-source\";\n"
  gnix << "  };\n\n"
  gnix << "  dontBuild = true;\n"
  gnix << "  dontConfigure = true;\n\n"
  gnix << "  passthru = { inherit bundle_path; };\n\n"

  gnix << "  installPhase = ''\n"
  gnix << "#{si}local dest=$out/${bundle_path}/bundler/gems/#{repo_key}\n"
  gnix << "#{si}mkdir -p $dest\n"
  gnix << "#{si}cp -r . $dest/\n"

  missing_gemspecs.each do |spec|
    gnix << "#{si}cat > $dest/#{spec.name}.gemspec <<'EOF'\n"
    gnix << "#{HD}Gem::Specification.new do |s|\n"
    gnix << "#{HD}  s.name = #{spec.name.inspect}\n"
    gnix << "#{HD}  s.version = #{spec.version.to_s.inspect}\n"
    gnix << "#{HD}  s.summary = #{spec.name.inspect}\n"
    gnix << "#{HD}  s.require_paths = [\"lib\"]\n"
    gnix << "#{HD}  s.files = []\n"
    gnix << "#{HD}end\n"
    gnix << "#{HD}EOF\n"
  end

  gnix << "  '';\n"
  gnix << "}\n"

  File.write(File.join(git_dir, "default.nix"), gnix)
  $stderr.puts "  -> nix/gem/#{repo[:base]}/git-#{repo[:shortrev]}/"

  # Patch the git rev into the selector's gitRevs attrset
  selector_path = File.join(OUTPUT_DIR, repo[:base], "default.nix")
  if File.exist?(selector_path)
    selector = File.read(selector_path)
    rev_line = "    #{repo[:shortrev].inspect} = import ./git-#{repo[:shortrev]} { inherit lib stdenv ruby; };\n"
    unless selector.include?(repo[:shortrev].inspect)
      selector.sub!("  gitRevs = {\n", "  gitRevs = {\n#{rev_line}")
      File.write(selector_path, selector)
    end
  else
    # No rubygems version exists — create a git-only selector
    sel = +""
    sel << "#\n"
    sel << "# ╔══════════════════════════════════════════════════════════════╗\n"
    sel << "# ║  GENERATED — do not edit.  Run bin/generate to regenerate  ║\n"
    sel << "# ╚══════════════════════════════════════════════════════════════╝\n"
    sel << "#\n"
    sel << "# #{repo[:base]} (git only)\n"
    sel << "#\n"
    sel << "# Available git revs:\n"
    sel << "#   #{repo[:shortrev]}\n"
    sel << "#\n"
    sel << "# Usage:\n"
    sel << "#   #{repo[:base]} { git.rev = #{repo[:shortrev].inspect}; }\n"
    sel << "#\n"
    sel << "{\n"
    sel << "  lib,\n"
    sel << "  stdenv,\n"
    sel << "  ruby,\n"
    sel << "  pkgs ? null,\n"
    sel << "  version ? null,\n"
    sel << "  git ? { },\n"
    sel << "}:\n"
    sel << "let\n"
    sel << "  versions = { };\n\n"
    sel << "  gitRevs = {\n"
    sel << "    #{repo[:shortrev].inspect} = import ./git-#{repo[:shortrev]} { inherit lib stdenv ruby; };\n"
    sel << "  };\n"
    sel << "in\n"
    sel << "if git ? rev then\n"
    sel << "  gitRevs.\${git.rev}\n"
    sel << "    or (throw \"#{repo[:base]}: unknown git rev '\${git.rev}'. Available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\")\n"
    sel << "else if version != null then\n"
    sel << "  throw \"#{repo[:base]}: no rubygems versions, only git revs: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\"\n"
    sel << "else\n"
    sel << "  throw \"#{repo[:base]}: specify git.rev — available: \${builtins.concatStringsSep \", \" (builtins.attrNames gitRevs)}\"\n"

    FileUtils.mkdir_p(File.dirname(selector_path))
    File.write(selector_path, sel)

    # Also add git-only gem to the top-level modules/gem.nix
    top_path = File.join(ROOT, "nix", "modules", "gem.nix")
    if File.exist?(top_path)
      top = File.read(top_path, encoding: "UTF-8")
      entry = "  #{repo[:base].inspect} = args: gem #{repo[:base].inspect} args;\n"
      unless top.include?(entry)
        top.sub!(/^}\n\z/, "#{entry}}\n")
        File.write(top_path, top)
      end
    end
  end
end
