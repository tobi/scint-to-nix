#!/usr/bin/env ruby
# frozen_string_literal: true

# fetch-top-gems â€” fetch the top N most-downloaded gems from rubygems.org
#
# For each gem, fetches the latest 3 versions (by semver, ruby platform only).
# Outputs a .gemset file suitable for bin/fetch + bin/generate.
#
# Usage:
#   bin/fetch-top-gems                     # top 1000, 3 versions each
#   bin/fetch-top-gems -n 500              # top 500
#   bin/fetch-top-gems -n 1000 -v 3        # explicit
#   bin/fetch-top-gems -o imports/top.gemset

require "net/http"
require "json"
require "uri"

count       = 1000
max_versions = 3
output_path = nil

i = 0
while i < ARGV.length
  case ARGV[i]
  when "-n", "--count"     then count = ARGV[i += 1].to_i
  when "-v", "--versions"  then max_versions = ARGV[i += 1].to_i
  when "-o", "--output"    then output_path = ARGV[i += 1]
  when "-h", "--help"
    $stderr.puts "Usage: fetch-top-gems [-n 1000] [-v 3] [-o imports/top.gemset]"
    exit 0
  end
  i += 1
end

# Step 1: Get top N gem names from search API (sorted by downloads)
$stderr.puts "Fetching top #{count} gems from rubygems.org search API..."

per_page = 30  # API max
pages_needed = (count.to_f / per_page).ceil
gem_names = []

pages_needed.times do |page_idx|
  page = page_idx + 1
  uri = URI("https://rubygems.org/api/v1/search.json?query=*&page=#{page}")
  
  retries = 0
  begin
    resp = Net::HTTP.get_response(uri)
    if resp.code == "429"
      wait = (resp["retry-after"] || "2").to_i + 1
      $stderr.puts "  Rate limited on page #{page}, waiting #{wait}s..."
      sleep wait
      retry
    end
    raise "HTTP #{resp.code}" unless resp.code == "200"
    
    data = JSON.parse(resp.body)
    break if data.empty?
    
    data.each do |gem|
      gem_names << gem["name"]
    end
    
    $stderr.print "\r  #{gem_names.size}/#{count} gem names fetched (page #{page}/#{pages_needed})"
    
    # Be polite to the API
    sleep 0.5
  rescue => e
    retries += 1
    if retries <= 3
      $stderr.puts "\n  Retry #{retries} for page #{page}: #{e.message}"
      sleep 2 * retries
      retry
    end
    $stderr.puts "\n  FAILED page #{page}: #{e.message}, skipping"
  end
  
  break if gem_names.size >= count
end

gem_names = gem_names.first(count)
$stderr.puts "\n#{gem_names.size} gem names collected"

# Step 2: For each gem, get version list from compact index and pick top 3
$stderr.puts "Fetching version info for #{gem_names.size} gems..."

lines = []
skipped = 0

gem_names.each_with_index do |name, idx|
  uri = URI("https://rubygems.org/info/#{name}")
  
  retries = 0
  begin
    resp = Net::HTTP.get_response(uri)
    if resp.code == "429"
      wait = (resp["retry-after"] || "2").to_i + 1
      $stderr.puts "\n  Rate limited on #{name}, waiting #{wait}s..."
      sleep wait
      retry
    end
    
    if resp.code != "200"
      $stderr.puts "\n  SKIP #{name}: HTTP #{resp.code}"
      skipped += 1
      next
    end
    
    # Parse versions: each line is "version deps|checksum:...,ruby:..."
    # Filter to ruby platform only (no -java, -x86, -mingw, etc.)
    versions = []
    resp.body.each_line do |line|
      line = line.strip
      next if line == "---" || line.empty?
      
      # Format: "1.2.3 dep1:>= 1.0,dep2:~> 2.0|checksum:abc123,ruby:>= 2.5"
      # Or:     "1.2.3-java dep1:...|checksum:..."
      ver_str = line.split(" ", 2).first
      
      # Skip platform-specific versions
      next if ver_str =~ /-(java|x86|x64|mingw|mswin|arm|aarch|darwin|linux|musl|freebsd)/i
      
      # Skip pre-release versions (contain .alpha, .beta, .rc, .pre, etc.)
      next if ver_str =~ /\.(alpha|beta|rc|pre)/i
      next if ver_str =~ /[a-zA-Z]/  # any letters = prerelease
      
      versions << ver_str
    end
    
    # Sort by Gem::Version (semver-aware) and take top 3
    sorted = versions.uniq.sort_by { |v| Gem::Version.new(v) rescue Gem::Version.new("0") }
    top = sorted.last(max_versions)
    
    top.each do |ver|
      lines << "#{name} #{ver}"
    end
    
    $stderr.print "\r  #{idx + 1}/#{gem_names.size} gems processed (#{lines.size} entries)"
    
    # Be polite
    sleep 0.1
  rescue => e
    retries += 1
    if retries <= 3
      $stderr.puts "\n  Retry #{retries} for #{name}: #{e.message}"
      sleep 2 * retries
      retry
    end
    $stderr.puts "\n  FAILED #{name}: #{e.message}"
    skipped += 1
  end
end

$stderr.puts "\n#{lines.size} gem versions from #{gem_names.size - skipped} gems (#{skipped} skipped)"

output = lines.sort.join("\n") + "\n"

if output_path
  require "fileutils"
  FileUtils.mkdir_p(File.dirname(output_path))
  File.write(output_path, output)
  $stderr.puts "-> #{output_path}"
else
  $stdout.write(output)
end
