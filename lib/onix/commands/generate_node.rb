# frozen_string_literal: true

require "rbconfig"

module Onix
  module Commands
    # Node-specific generation methods, included by Generate.
    module NodeGenerator
      private

      # ── Node prefetch ─────────────────────────────────────────

      def prefetch_npm(packages, jobs, hashes, progress)
        errors = []
        mutex = Mutex.new
        queue = Queue.new
        packages.each { |p| queue << p }
        jobs.times { queue << nil }

        threads = jobs.times.map do
          Thread.new do
            while (e = queue.pop)
              # Use exact tarball URL from lockfile when available (private registries),
              # otherwise construct from registry URL
              url = if e.tarball
                e.tarball
              else
                basename = e.name.include?("/") ? e.name.split("/").last : e.name
                "#{e.remote}/#{e.name}/-/#{basename}-#{e.version}.tgz"
              end
              # Use .npmrc auth for private registries, fall back to scint credentials
              auth_url = @npmrc ? @npmrc.inject_auth(url) : inject_credentials(url)
              sha256 = nix_prefetch_url(auth_url)

              key = "#{e.name}/#{e.version}"
              mutex.synchronize do
                if sha256
                  hashes[key] = sha256
                  progress.advance
                else
                  errors << "#{e.name} #{e.version}: failed to prefetch"
                  progress.advance(success: false)
                end
              end
            end
          end
        end
        threads.each(&:join)
        errors
      end

      # ── Node nix writers ─────────────────────────────────────

      def write_npm_nix(dir, name, entries, sha256_for)
        nix = +"# #{name} — generated by onix. Do not edit.\n{\n"

        entries.sort_by(&:version).each do |e|
          sha256 = sha256_for["#{e.name}/#{e.version}"] || ""
          nix << "  #{nix_str e.version} = {\n"
          nix << "    version = #{nix_str e.version};\n"

          if e.source == "git"
            nix << "    source = {\n"
            nix << "      type = \"git\";\n"
            nix << "      url = #{nix_str e.uri};\n"
            nix << "      rev = #{nix_str e.rev};\n"
            nix << "      sha256 = #{nix_str sha256};\n"
            nix << "    };\n"
            nix << "    subdir = #{nix_str e.subdir};\n" if e.subdir && e.subdir != "."
          else
            nix << "    source = {\n"
            nix << "      type = \"tarball\";\n"
            nix << "      remotes = [ #{nix_str e.remote} ];\n"
            nix << "      sha256 = #{nix_str sha256};\n"
            nix << "      url = #{nix_str e.tarball};\n" if e.tarball
            nix << "    };\n"
          end

          nix << "    integrity = #{nix_str e.integrity};\n" if e.integrity

          if e.bin && !e.bin.empty?
            nix << "    bin = {\n"
            e.bin.sort.each do |bin_name, bin_path|
              nix << "      #{nix_str bin_name} = #{nix_str bin_path};\n"
            end
            nix << "    };\n"
          end

          nix << "    hasNative = true;\n" if e.has_native
          if e.os && !e.os.empty?
            nix << "    os = [ #{e.os.map { |o| nix_str(o) }.join(" ")} ];\n"
          end
          if e.cpu && !e.cpu.empty?
            nix << "    cpu = [ #{e.cpu.map { |c| nix_str(c) }.join(" ")} ];\n"
          end
          nix << "  };\n"
        end

        nix << "}\n"
        safe_name = entries.first.safe_nix_filename
        File.write(File.join(dir, "#{safe_name}.nix"), nix)
      end

      def write_node_project_nix(dir, project_name, entries, meta)
        buildable = entries.reject { |e| e.source == "builtin" || e.source == "path" }

        # Deduplicated, sorted package list
        unique_packages = buildable.uniq { |e| [e.name, e.version] }
                                   .sort_by { |e| [e.name, e.version] }

        nix = +"# #{project_name} — generated by onix. Do not edit.\n"
        # Use node version from meta if available, otherwise default to nodejs_22
        nodejs_attr = "nodejs_22"
        if meta&.node
          major = meta.node.to_s.split(".").first
          nodejs_attr = "nodejs_#{major}" if major.to_i >= 18
        end
        nix << "{ pkgs ? import <nixpkgs> { config = {}; overlays = []; }, nodejs ? pkgs.#{nodejs_attr} }:\n"
        nix << "let\n"
        nix << "  buildNpm = import ./build-npm.nix { inherit pkgs nodejs; };\n"
        nix << "  buildPackageByName = name:\n"
        nix << "    let\n"
        nix << "      versions = import (./node + \"/\${name}.nix\");\n"
        nix << "      version = pkgs.lib.last (builtins.attrNames versions);\n"
        nix << "      spec = versions.\${version};\n"
        nix << "    in buildNpm (spec // { pkgName = name; });\n"
        nix << "  npmConfig = import ./npm-config.nix {\n"
        nix << "    inherit pkgs nodejs;\n"
        nix << "    overlayDir = ../overlays/node;\n"
        nix << "    nodeDir = ./node;\n"
        nix << "    buildPackageFn = buildPackageByName;\n"
        nix << "  };\n"
        nix << "\n"
        nix << "  build = name: version:\n"
        nix << "    let\n"
        nix << "      safeName = builtins.replaceStrings [\"/\" \"@\"] [\"--\" \"\"] name;\n"
        nix << "      versions = import (./node + \"/\${safeName}.nix\");\n"
        nix << "      spec = versions.\${version};\n"
        nix << "      config = npmConfig.\${name} or {};\n"
        nix << "    in buildNpm (spec // {\n"
        nix << "      pkgName = name;\n"
        nix << "      hasNative = (spec.hasNative or false) || (config ? deps && config.deps != []);\n"
        nix << "      nativeBuildInputs = config.deps or [];\n"
        nix << "      buildFlags = config.buildFlags or \"\";\n"
        nix << "      beforeBuild = config.beforeBuild or \"\";\n"
        nix << "      afterBuild = config.afterBuild or \"\";\n"
        nix << "    } // (if config ? buildPhase then { inherit (config) buildPhase; } else {})\n"
        nix << "      // (if config ? postInstall then { inherit (config) postInstall; } else {})\n"
        nix << "      // (if config ? skip then { inherit (config) skip; } else {})\n"
        nix << "      // (if config ? buildPackages then { inherit (config) buildPackages; } else {}));\n"
        nix << "\n"
        nix << "  packages = {\n"
        unique_packages.each do |e|
          key = nix_key("#{e.name}@#{e.version}")
          nix << "    #{key} = build #{nix_str e.name} #{nix_str e.version};\n"
        end
        nix << "  };\n"
        nix << "\n"
        nix << "  packageDir = pkgs.runCommand #{nix_str "#{project_name}-packages"} {} ''\n"
        nix << "    mkdir -p $out\n"
        # Collect scoped package prefixes that need directories
        scopes = unique_packages.select { |e| e.name.include?("/") }
                                .map { |e| e.name.split("/").first }
                                .uniq.sort
        scopes.each do |scope|
          nix << "    mkdir -p \"$out/#{scope}\"\n"
        end
        unique_packages.each do |e|
          key = nix_key("#{e.name}@#{e.version}")
          nix << "    ln -s ${packages.#{key}} \"$out/#{e.name}@#{e.version}\"\n"
        end
        nix << "  '';\n"
        nix << "in packages // { inherit packageDir; }\n"

        File.write(File.join(dir, "#{project_name}.nix"), nix)
        UI.wrote "nix/#{project_name}.nix"
      end

      NIX_TO_NPM = {
        "x86_64-linux"   => ["linux", "x64"],
        "aarch64-linux"  => ["linux", "arm64"],
        "x86_64-darwin"  => ["darwin", "x64"],
        "aarch64-darwin" => ["darwin", "arm64"],
      }.freeze

      def detect_host_platform
        host_os = RbConfig::CONFIG["host_os"]
        host_cpu = RbConfig::CONFIG["host_cpu"]
        os = host_os.include?("darwin") ? "darwin" : "linux"
        cpu = (host_cpu == "arm64" || host_cpu == "aarch64") ? "arm64" : "x64"
        [os, cpu]
      end

      def platform_matches?(entry, target_platforms)
        return true if entry.os.empty? && entry.cpu.empty?

        target_platforms.any? do |npm_os, npm_cpu|
          os_ok = entry.os.empty? || matches_constraint?(entry.os, npm_os)
          cpu_ok = entry.cpu.empty? || matches_constraint?(entry.cpu, npm_cpu)
          os_ok && cpu_ok
        end
      end

      def matches_constraint?(constraints, actual)
        constraints.any? { |c| c.start_with?("!") ? actual != c[1..] : actual == c }
      end

      def resolve_target_platforms(platforms_arg)
        return nil if platforms_arg == "all"

        host_os, host_cpu = detect_host_platform
        targets = [[host_os, host_cpu]]

        if platforms_arg
          platforms_arg.split(",").map(&:strip).each do |triple|
            npm = NIX_TO_NPM[triple]
            unless npm
              UI.fail "Unknown platform: #{triple}. Supported: #{NIX_TO_NPM.keys.join(", ")}"
              exit 1
            end
            targets << npm
          end
        end

        targets.uniq
      end
    end
  end
end
